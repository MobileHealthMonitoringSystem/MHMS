###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       26/Apr/2013  16:24:40 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\Source\tvsa.c                 #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1             #
#                     -DHAL_UART=1 -DZAP_PHY_SPI=1                            #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\Source\tvsa.c -lC             #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\ -lA  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\      #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\       #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\tvsa. #
#                     lst                                                     #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\tvsa.r #
#                     43                                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\Source\tvsa.c
      1          /**************************************************************************************************
      2              Filename:       tvsa.c
      3              Revised:        $Date: 2011-07-25 20:23:05 -0700 (Mon, 25 Jul 2011) $
      4              Revision:       $Revision: 26899 $
      5          
      6              Description:
      7          
      8              This file implements the Temperature/Voltage Sample Application.
      9          
     10          
     11          
     12          
     13              Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     14          
     15              IMPORTANT: Your use of this Software is limited to those specific rights
     16              granted under the terms of a software license agreement between the user
     17              who downloaded the software, his/her employer (which must be your employer)
     18              and Texas Instruments Incorporated (the "License").  You may not use this
     19              Software unless you agree to abide by the terms of the License. The License
     20              limits your use, and you acknowledge, that the Software may not be modified,
     21              copied or distributed unless embedded on a Texas Instruments microcontroller
     22              or used solely and exclusively in conjunction with a Texas Instruments radio
     23              frequency transceiver, which is integrated into your product.  Other than for
     24              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25              works of, modify, distribute, perform, display or sell this Software and/or
     26              its documentation for any purpose.
     27          
     28              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40              Should you have any questions regarding your right to use this Software,
     41              contact Texas Instruments Incorporated at www.TI.com.
     42          **************************************************************************************************/
     43          
     44          /* ------------------------------------------------------------------------------------------------
     45           *                                          Includes
     46           * ------------------------------------------------------------------------------------------------
     47           */
     48          
     49          #include "af.h"
     50          #if defined LCD_SUPPORTED
     51          #include "hal_lcd.h"

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x244
   \   union <unnamed> _A_PCDIR_L
   \                     _A_PCDIR_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x1b0
   \   union <unnamed> _A_REFCTL0_L
   \                     _A_REFCTL0_L:
   \   000000                DS8 2
     52          #endif
     53          #include "hal_uart.h"
     54          #include "OnBoard.h"
     55          #include "OSAL.h"
     56          #include "tvsa.h"
     57          #include "ZComDef.h"
     58          #include "ZDApp.h"
     59          #include "hal_led.h"  //MHMS for indicating if pulse is found
     60          #include "hal_adc.h"  //MHMS used for capturing signal from pulse sensor
     61          
     62          /* ------------------------------------------------------------------------------------------------
     63           *                                           Constants
     64           * ------------------------------------------------------------------------------------------------
     65           */
     66          
     67          // Constants for Pulse Sensor
     68          

   \                                 In  segment DATA16_C, align 2, align-sorted
     69          static const cId_t PULSE_ClusterList[PULSE_CLUSTER_CNT] =
   \                     PULSE_ClusterList:
   \   000000   0200         DC16 2
     70          {
     71            PULSE_CLUSTER_ID
     72          };
     73          

   \                                 In  segment DATA16_C, align 2, align-sorted
     74          static const SimpleDescriptionFormat_t PULSE_SimpleDesc =
   \                     PULSE_SimpleDesc:
   \   000000   0300         DC8 3, 0
   \   000002   100F0600     DC16 3856, 6
   \   000006   0001         DC8 0, 1
   \   000008   ....         DC16 PULSE_ClusterList
   \   00000A   0100         DC8 1, 0
   \   00000C   ....         DC16 PULSE_ClusterList
     75          {
     76            PULSE_ENDPOINT,
     77            PULSE_PROFILE_ID,
     78            PULSE_DEVICE_ID,
     79            PULSE_DEVICE_VERSION,
     80            PULSE_FLAGS,
     81            PULSE_CLUSTER_CNT,
     82            (cId_t *)PULSE_ClusterList,
     83            PULSE_CLUSTER_CNT,
     84            (cId_t *)PULSE_ClusterList
     85          };
     86          

   \                                 In  segment DATA16_C, align 2, align-sorted
     87          static const endPointDesc_t PULSE_epDesc=
   \                     PULSE_epDesc:
   \   000000   0300         DC8 3, 0
   \   000002   ........     DC16 pulseTaskId, PULSE_SimpleDesc
   \   000006   0000         DC8 0, 0
     88          {
     89            PULSE_ENDPOINT,
     90            &pulseTaskId,
     91            (SimpleDescriptionFormat_t *)&PULSE_SimpleDesc,
     92            noLatencyReqs,
     93          };
     94          /* ------------------------------------------------------------------------------------------------
     95           *                                           Typedefs
     96           * ------------------------------------------------------------------------------------------------
     97           */
     98          
     99          /* ------------------------------------------------------------------------------------------------
    100           *                                           Macros
    101           * ------------------------------------------------------------------------------------------------
    102           */
    103          
    104          /* ------------------------------------------------------------------------------------------------
    105           *                                           Global Variables
    106           * ------------------------------------------------------------------------------------------------
    107           */
    108          
    109          #if TVSA_DATA_CNF
    110          uint8 pulseCnfErrCnt;
    111          #endif
    112          
    113          //MHMS  Global Variables

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    114          uint8 pulseTaskId;
   \                     pulseTaskId:
   \   000000                DS8 1
    115          
    116          //(void)osal_set_event(pulseTaskId, TEST_EVT_PAYLOAD_TX);   //For testing payload TX
    117          /* ------------------------------------------------------------------------------------------------
    118           *                                           Local Variables
    119           * ------------------------------------------------------------------------------------------------
    120           */
    121          
    122          // Network address of the TVSA Dongle.
    123          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    124          static uint16 pulseAddr;
   \                     pulseAddr:
   \   000000                DS8 2
    125          // Report counter.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    126          static uint16 pulseCnt;  //MHMS Question what is this for?
   \                     pulseCnt:
   \   000000                DS8 2
    127          // ZigBee-required packet transaction sequence number in calls to AF_DataRequest().
    128          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    129          static uint8 pulseTSN;           //MHMS Question what is thi?
   \                     pulseTSN:
   \   000000                DS8 1
    130          
    131          //Data arrays for Over the air data tx and RX

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    132          static uint8 pulseBuf[PULSE_BUF_LEN];  //MHMS buffer used for recived over the air data
   \                     pulseBuf:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    133          static uint8 pulseDat[PULSE_DAT_LEN];  //MHMS define data array length for Pulse sensor
   \                     pulseDat:
   \   000000                DS8 22

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    134          static uint8 TestDatTx[MHMS_TEST_PAYLOAD_LEN];
   \                     TestDatTx:
   \   000000                DS8 50

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    135          static uint8 TestRxBuffer[MHMS_TEST_BUFF_LEN];
   \                     TestRxBuffer:
   \   000000                DS8 53
    136          
    137          //Syncronization Flags

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    138          static bool PulseEvtDat_sync = FALSE;  
   \                     PulseEvtDat_sync:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    139          static bool PulseEvtReq_sync;
   \                     PulseEvtReq_sync:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    140          static bool PulseEvtCheckin_sync;  
   \                     PulseEvtCheckin_sync:
   \   000000                DS8 1
    141             
    142          
    143          // these variables are volatile because they are used during the interrupt service routine!
    144          //MHMS From Arduino 1.1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    145          volatile int BPM;                   // used to hold the pulse rate
   \                     BPM:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    146          volatile int Signal;                // holds the incoming raw data
   \                     Signal:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    147          volatile int IBI = 600;             // holds the time between beats, the Inter-Beat Interval
   \                     IBI:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for IBI>`

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    148          volatile bool Pulse = FALSE;     // TRUE when pulse wave is high, FALSE when it's low
   \                     Pulse:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    149          volatile bool QS = FALSE;        // becomes TRUE when Arduoino finds a beat.  
   \                     QS:
   \   000000                DS8 1
    150          
    151          
    152          
    153          /* ------------------------------------------------------------------------------------------------
    154           *                                           Local Functions
    155           * ------------------------------------------------------------------------------------------------
    156           */
    157          
    158          static void pulseAfMsgRx(afIncomingMSGPacket_t *msg);
    159          static void pulseSysEvtMsg(void);
    160          
    161          
    162          static void pulseBPM(uint8 *pulsedata);  //MHMS Pulse calculation function
    163          static void pulseDataCalc(void);
    164          static void pulseDataReq(void);
    165          static void pulseZdoStateChange(void);
    166          
    167          static void pulseNodeCheckIn(void);
    168          static void TestPayloadTx(void);
    169          
    170          static void pulseAnnce(void);
    171          static void pulseDataRx(afIncomingMSGPacket_t *msg);
    172          static void pulseTestingDataRx(afIncomingMSGPacket_t *msg);
    173          
    174          static void pulseUartRx(uint8 port, uint8 event);
    175          
    176          
    177          #ifndef TVSA_DEMO  //MHMS Question do we need this?
    178          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    179          static void sysPingRsp(void);
    180          #endif
    181          
    182          /*  //MHMS Pulse Sensor Functions */ 
    183          
    184          /**************************************************************************************************
    185           * @fn          pulseAppInit
    186           *
    187           * @brief       This function is the application's task initialization.
    188           *
    189           * input parameters
    190           *
    191           * None.
    192           *
    193           * output parameters
    194           *
    195           * None.
    196           *
    197           * @return      None.
    198           **************************************************************************************************
    199           */

   \                                 In  segment CODE, align 2
    200          void pulseAppInit(uint8 id)
   \                     pulseAppInit:
    201          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31802200     SUB.W   #0x22, SP
   \   000006   4A4C         MOV.B   R12, R10
    202          
    203            halUARTCfg_t uartConfig;
    204          
    205            uartConfig.configured           = TRUE;              // 2x30 don't care - see uart driver.
   \   000008   D1430000     MOV.B   #0x1, 0(SP)
    206            
    207          
    208            uartConfig.baudRate             = HAL_UART_BR_38400;        //MHMS This baud rate is required to communicate with Zigbee Sensor Monitor
   \   00000C   E1430100     MOV.B   #0x2, 0x1(SP)
    209            //uartConfig.baudRate             = HAL_UART_BR_115200;         //MHMS This baud rate is required to communicate with the Pulse processing program on PC
    210          
    211            
    212            uartConfig.flowControl          = FALSE;
   \   000010   C1430200     MOV.B   #0x0, 0x2(SP)
    213            uartConfig.flowControlThreshold = 16;                // 2x30 don't care - see uart driver.
   \   000014   B14010000400 MOV.W   #0x10, 0x4(SP)
    214            uartConfig.rx.maxBufSize        = 32;                // 2x30 don't care - see uart driver.
   \   00001A   B14020000C00 MOV.W   #0x20, 0xc(SP)
    215            uartConfig.tx.maxBufSize        = 254;               // 2x30 don't care - see uart driver.
   \   000020   B140FE001400 MOV.W   #0xfe, 0x14(SP)
    216            uartConfig.idleTimeout          = 6;                 // 2x30 don't care - see uart driver.
   \   000026   F14006000600 MOV.B   #0x6, 0x6(SP)
    217            uartConfig.intEnable            = TRUE;              // 2x30 don't care - see uart driver.
   \   00002C   D1431800     MOV.B   #0x1, 0x18(SP)
    218            uartConfig.callBackFunc         = pulseUartRx;
   \   000030   B140....1E00 MOV.W   #LWRD(pulseUartRx), 0x1e(SP)
   \   000036   B140....2000 MOV.W   #HWRD(pulseUartRx), 0x20(SP)
    219            HalUARTOpen(PULSE_PORT, &uartConfig);
   \   00003C   0D41         MOV.W   SP, R13
   \   00003E   0D53         ADD.W   #0x0, R13
   \   000040   4C43         MOV.B   #0x0, R12
   \   000042   ........     CALLA   #HalUARTOpen
    220          
    221              pulseDat[PULSE_TYP_IDX] = (uint8)PULSE_DEVICE_ID;
   \   000046   F2400600.... MOV.B   #0x6, &pulseDat + 19
    222              TestDatTx[MHMS_TEST_PAYLOAD_LEN - 3] = (uint8)PULSE_DEVICE_ID;
   \   00004C   F2400600.... MOV.B   #0x6, &TestDatTx + 47
    223          #if defined PULSE_SRC_RTG
    224          
    225              pulseDat[PULSE_OPT_IDX] = PULSE_OPT_SRC_RTG;
   \   000052   D243....     MOV.B   #0x1, &pulseDat + 20
    226              TestDatTx[MHMS_TEST_PAYLOAD_LEN - 1] = PULSE_OPT_SRC_RTG;
   \   000056   D243....     MOV.B   #0x1, &TestDatTx + 49
    227          #endif
    228          
    229            pulseTaskId = id;                                    
   \   00005A   C24A....     MOV.B   R10, &pulseTaskId
    230            pulseAddr = INVALID_NODE_ADDR;
   \   00005E   B240FEFF.... MOV.W   #0xfffe, &pulseAddr
    231            (void)afRegister((endPointDesc_t *)&PULSE_epDesc);  //MHMS registers endpoint object
   \   000064   3C40....     MOV.W   #PULSE_epDesc, R12
   \   000068   ........     CALLA   #afRegister
    232            
    233            //Initialize Px.y (5.0) to power Pulse sensor
    234            P5DIR = 0x1;  //Set IO direction as output
   \   00006C   D2434402     MOV.B   #0x1, &0x244
    235            P5OUT = 0x1;  //Set output to high
   \   000070   D2434202     MOV.B   #0x1, &0x242
    236           
    237            //Setup ADC reference 
    238            REFCTL0 = REFVSEL_2;  /* REF Reference Voltage Level Select 2.5V */
   \   000074   B2402000B001 MOV.W   #0x20, &0x1b0
    239          }
   \   00007A   31502200     ADD.W   #0x22, SP
   \   00007E   3A41         POP.W   R10
   \   000080   1001         RETA
   \   000082                REQUIRE _A_PCDIR_L
   \   000082                REQUIRE _A_PCOUT_L
   \   000082                REQUIRE _A_REFCTL0_L
    240          
    241          /**************************************************************************************************
    242           * @fn          pulseAppEvt
    243           *
    244           * @brief       This function is called to process the OSAL events for the task.
    245           *
    246           * input parameters
    247           *
    248           * @param       id - OSAL task Id.
    249           * @param       evts - OSAL events bit mask of pending events.
    250           *
    251           * output parameters
    252           *
    253           * None.
    254           *
    255           * @return      evts - OSAL events bit mask of unprocessed events.
    256           **************************************************************************************************
    257           */

   \                                 In  segment CODE, align 2
    258          uint16 pulseAppEvt(uint8 id, uint16 evts)
   \                     pulseAppEvt:
    259          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4D         MOV.W   R13, R10
    260            uint16 mask = 0;
    261            (void)id;  //MHMS casts a void to ignore warning for not using variable
    262            
    263            if (evts & SYS_EVENT_MSG)
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1934         JGE     ??pulseAppEvt_3
    264            {
    265              mask = SYS_EVENT_MSG;
   \   000008   3B400080     MOV.W   #0x8000, R11
    266              pulseSysEvtMsg();
   \   00000C   053C         JMP     ??pulseAppEvt_4
   \                     ??pulseAppEvt_0:
   \   00000E   ........     CALLA   #pulseAfMsgRx
   \                     ??pulseAppEvt_1:
   \   000012   0C48         MOV.W   R8, R12
   \   000014   ........     CALLA   #osal_msg_deallocate
   \                     ??pulseAppEvt_4:
   \   000018   5C42....     MOV.B   &pulseTaskId, R12
   \   00001C   ........     CALLA   #osal_msg_receive
   \   000020   084C         MOV.W   R12, R8
   \   000022   0C93         CMP.W   #0x0, R12
   \   000024   3324         JEQ     ??pulseAppEvt_5
   \   000026   6E4C         MOV.B   @R12, R14
   \   000028   7E801A00     SUB.B   #0x1a, R14
   \   00002C   F027         JEQ     ??pulseAppEvt_0
   \   00002E   7E80B700     SUB.B   #0xb7, R14
   \   000032   EF23         JNE     ??pulseAppEvt_1
   \   000034   ........     CALLA   #pulseZdoStateChange
   \   000038   EC3F         JMP     ??pulseAppEvt_1
    267            }
    268          
    269            else if (evts & PULSE_EVT_ANN)
   \                     ??pulseAppEvt_3:
   \   00003A   3DB00040     BIT.W   #0x4000, R13
   \   00003E   0528         JNC     ??pulseAppEvt_6
    270            {
    271              mask = PULSE_EVT_ANN;
   \   000040   3B400040     MOV.W   #0x4000, R11
    272             pulseAnnce();
   \   000044   ........     CALLA   #pulseAnnce
   \   000048   213C         JMP     ??pulseAppEvt_5
    273            }
    274          
    275            else if (evts & PULSE_EVT_DAT)
   \                     ??pulseAppEvt_6:
   \   00004A   3DB00010     BIT.W   #0x1000, R13
   \   00004E   0528         JNC     ??pulseAppEvt_7
    276            {
    277              mask = PULSE_EVT_DAT;
   \   000050   3B400010     MOV.W   #0x1000, R11
    278              pulseDataCalc();
   \   000054   ........     CALLA   #pulseDataCalc
   \   000058   193C         JMP     ??pulseAppEvt_5
    279            }
    280            else if (evts & PULSE_EVT_REQ)
   \                     ??pulseAppEvt_7:
   \   00005A   3DB00020     BIT.W   #0x2000, R13
   \   00005E   0528         JNC     ??pulseAppEvt_8
    281            {
    282              mask = PULSE_EVT_REQ;
   \   000060   3B400020     MOV.W   #0x2000, R11
    283              pulseDataReq();
   \   000064   ........     CALLA   #pulseDataReq
   \   000068   113C         JMP     ??pulseAppEvt_5
    284            }
    285              else if (evts & PULSE_EVT_CHECKIN)
   \                     ??pulseAppEvt_8:
   \   00006A   3DB00008     BIT.W   #0x800, R13
   \   00006E   0528         JNC     ??pulseAppEvt_9
    286            {
    287              mask = PULSE_EVT_CHECKIN;
   \   000070   3B400008     MOV.W   #0x800, R11
    288              pulseNodeCheckIn();
   \   000074   ........     CALLA   #pulseNodeCheckIn
   \   000078   093C         JMP     ??pulseAppEvt_5
    289            }
    290          
    291          else if (evts & TEST_EVT_PAYLOAD_TX)
   \                     ??pulseAppEvt_9:
   \   00007A   3DB00004     BIT.W   #0x400, R13
   \   00007E   0528         JNC     ??pulseAppEvt_10
    292            {
    293              mask = TEST_EVT_PAYLOAD_TX;
   \   000080   3B400004     MOV.W   #0x400, R11
    294              TestPayloadTx();
   \   000084   ........     CALLA   #TestPayloadTx
   \   000088   013C         JMP     ??pulseAppEvt_5
    295            }
    296            else
    297            {
    298              mask = evts;  // Discard unknown events - should never happen.
   \                     ??pulseAppEvt_10:
   \   00008A   0B4D         MOV.W   R13, R11
    299            }
    300          
    301            return (evts ^ mask);  // Return unprocessed events.
   \                     ??pulseAppEvt_5:
   \   00008C   0AEB         XOR.W   R11, R10
   \   00008E   0C4A         MOV.W   R10, R12
   \   000090   3817         POPM.W  #0x4, R11
   \   000092   1001         RETA
    302          }
    303          
    304          
    305          //MHMS put coord stuff here, recieve func and sys
    306          
    307          
    308          
    309          /**************************************************************************************************
    310           * @fn          pulseSysEvtMsg
    311           *
    312           * @brief       This function is called by pulseAppEvt() to process all of the pending OSAL messages.
    313           *
    314           * input parameters
    315           *
    316           * None.
    317           *
    318           * output parameters
    319           *
    320           * None.
    321           *
    322           * @return      None.
    323           **************************************************************************************************
    324           */
    325          static void pulseSysEvtMsg(void)
    326          {
    327            uint8 *msg;
    328          
    329            while ((msg = osal_msg_receive(pulseTaskId)))
    330            {
    331              switch (*msg)
    332              {
    333          #if TVSA_DATA_CNF  //MHMS Question what is this for?
    334              case AF_DATA_CONFIRM_CMD:
    335                if (ZSuccess != ((afDataConfirm_t *)msg)->hdr.status)
    336                {
    337                  if (0 == ++pulseCnfErrCnt)
    338                  {
    339                    pulseCnfErrCnt = 255;
    340                  }
    341                }
    342                break;
    343          #endif
    344          
    345              case AF_INCOMING_MSG_CMD:  //MHMS this a router processing the incomming command from the coordinator
    346                pulseAfMsgRx((afIncomingMSGPacket_t *)msg);
    347                break;
    348          
    349              case ZDO_STATE_CHANGE:
    350                pulseZdoStateChange();
    351                break;
    352          
    353              default:
    354                break;
    355              }
    356          
    357              (void)osal_msg_deallocate(msg);  // Receiving task is responsible for releasing the memory.
    358            }
    359          }
    360          
    361          /**************************************************************************************************
    362           * @fn          pulseAfMsgRx
    363           *
    364           * @brief       This function is called by pulseSysEvtMsg() to process an incoming AF message.
    365           *
    366           * input parameters
    367           *
    368           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    369           *
    370           * output parameters
    371           *
    372           * None.
    373           *
    374           * @return      None.
    375           **************************************************************************************************
    376           */

   \                                 In  segment CODE, align 2
   \                     ??Subroutine15_0:
   \   000000   5C42....     MOV.B   &pulseTaskId, R12
   \   000004   ........     BRA     #osal_set_event

   \                                 In  segment CODE, align 2
   \                     ?Subroutine11:
   \   000000   B290FEFF.... CMP.W   #0xfffe, &pulseAddr
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    377          static void pulseAfMsgRx(afIncomingMSGPacket_t *msg)
   \                     pulseAfMsgRx:
    378          {
   \   000000   0A12         PUSH.W  R10
    379            uint8 *buf = msg->cmd.Data;
   \   000002   1A4C2400     MOV.W   0x24(R12), R10
    380          
    381            switch (buf[PULSE_CMD_IDX])
   \   000006   6E4A         MOV.B   @R10, R14
   \   000008   4E83         SUB.B   #0x0, R14
   \   00000A   0724         JEQ     ??pulseAfMsgRx_0
   \   00000C   5E83         SUB.B   #0x1, R14
   \   00000E   0824         JEQ     ??pulseAfMsgRx_1
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   1D24         JEQ     ??pulseAfMsgRx_2
   \   000014   5E83         SUB.B   #0x1, R14
   \   000016   2324         JEQ     ??pulseAfMsgRx_3
   \   000018   243C         JMP     ??pulseAfMsgRx_4
    382            {
    383          
    384            case PULSE_CMD_DAT:  //Nodes will send this by default
    385              pulseDataRx(msg);
   \                     ??pulseAfMsgRx_0:
   \   00001A   ........     CALLA   #pulseDataRx
    386              break;
   \   00001E   213C         JMP     ??pulseAfMsgRx_4
    387          
    388            case PULSE_CMD_BEG:
    389              if (INVALID_NODE_ADDR == pulseAddr)
   \                     ??pulseAfMsgRx_1:
   \   000020   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_16:
   \   000024   0A20         JNE     ??pulseAfMsgRx_5
    390              {
    391                NLME_SetPollRate(0);
   \   000026   0C43         MOV.W   #0x0, R12
   \   000028   ........     CALLA   #NLME_SetPollRate
    392                if(PulseEvtDat_sync == FALSE){
   \   00002C   C293....     CMP.B   #0x0, &PulseEvtDat_sync
   \   000030   0420         JNE     ??pulseAfMsgRx_5
    393                (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);           //Sync Pulsedat event operation
   \   000032   3D400010     MOV.W   #0x1000, R13
   \   000036   ........     CALLA   #??Subroutine15_0
    394                
    395                }
    396              }
    397              pulseAddr = BUILD_UINT16(buf[PULSE_ADR_LSB], buf[PULSE_ADR_MSB]);
   \                     ??pulseAfMsgRx_5:
   \   00003A   5E4A0100     MOV.B   0x1(R10), R14
   \   00003E   5F4A0200     MOV.B   0x2(R10), R15
   \   000042                RPT     #0x8
   \   000042   47180F5F     RLAX.W  R15
   \   000046   0E5F         ADD.W   R15, R14
   \   000048   824E....     MOV.W   R14, &pulseAddr
    398              break;
   \   00004C   0A3C         JMP     ??pulseAfMsgRx_4
    399          
    400            case PULSE_CMD_END:
    401              NLME_SetPollRate(POLL_RATE);
   \                     ??pulseAfMsgRx_2:
   \   00004E   3C40E803     MOV.W   #0x3e8, R12
   \   000052   ........     CALLA   #NLME_SetPollRate
    402              pulseAddr = INVALID_NODE_ADDR;
   \   000056   B240FEFF.... MOV.W   #0xfffe, &pulseAddr
    403              break;
   \   00005C   023C         JMP     ??pulseAfMsgRx_4
    404          
    405            case PULSE_CMD_DAT_TEST:  //This is used for testing different payload sizes. Not used in normal operation
    406              pulseTestingDataRx(msg);
   \                     ??pulseAfMsgRx_3:
   \   00005E   ........     CALLA   #pulseTestingDataRx
    407              break;
    408          
    409            default:
    410              break;
    411            }
    412          }
   \                     ??pulseAfMsgRx_4:
   \   000062   3A41         POP.W   R10
   \   000064   1001         RETA
    413          
    414          /**************************************************************************************************
    415           * @fn          pulseDataRx
    416           *
    417           * @brief       This function is called by pulseAfMsgRx() to process incoming PULSE data.
    418           *
    419           * input parameters
    420           *
    421           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    422           *
    423           * output parameters
    424           *
    425           * None.
    426           *
    427           * @return      None.
    428           **************************************************************************************************
    429           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   F140FE000000 MOV.B   #0xfe, 0(SP)
   \   000006   F1400A000100 MOV.B   #0xa, 0x1(SP)
   \   00000C   F14046000200 MOV.B   #0x46, 0x2(SP)
   \   000012   F14087000300 MOV.B   #0x87, 0x3(SP)
   \   000018   E14A0400     MOV.B   @R10, 0x4(SP)
   \   00001C   D14A01000500 MOV.B   0x1(R10), 0x5(SP)
   \   000022   E1430600     MOV.B   #0x2, 0x6(SP)
   \   000026   C1430700     MOV.B   #0x0, 0x7(SP)
   \   00002A   E1420800     MOV.B   #0x4, 0x8(SP)
   \   00002E   C1430900     MOV.B   #0x0, 0x9(SP)
   \   000032   C14D0A00     MOV.B   R13, 0xa(SP)
   \   000036   C14D0B00     MOV.B   R13, 0xb(SP)
   \   00003A   C14E0C00     MOV.B   R14, 0xc(SP)
   \   00003E   C14F0D00     MOV.B   R15, 0xd(SP)
   \   000042   7D400D00     MOV.B   #0xd, R13
   \   000046   0C41         MOV.W   SP, R12
   \   000048   1C53         ADD.W   #0x1, R12
   \   00004A   ........     CALLA   #calcFCS
   \   00004E   C14C0E00     MOV.B   R12, 0xe(SP)
   \   000052   3E400F00     MOV.W   #0xf, R14
   \   000056   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_5:
   \   00005A   31501000     ADD.W   #0x10, SP
   \   00005E   3817         POPM.W  #0x4, R11
   \   000060   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   2D52         ADD.W   #0x4, R13
   \   000004   4C43         MOV.B   #0x0, R12
   \   000006   ........     BRA     #HalUARTWrite

   \                                 In  segment CODE, align 2
    430          static void pulseDataRx(afIncomingMSGPacket_t *msg)
   \                     pulseDataRx:
    431          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   ........     CALLA   #?Subroutine3
    432            uint8 fcs = 0, idx;
    433          
    434            // Last announce broadcast to stop must have expired before a parent could forward to a ZED.
    435            if (INVALID_NODE_ADDR == pulseAddr)
    436            {
    437              (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
    438            }
    439          
    440            pulseBuf[PULSE_SOP_IDX] = PULSE_SOP_VAL;
   \                     ??CrossCallReturnLabel_4:
   \   00000A   F240FE00.... MOV.B   #0xfe, &pulseBuf
    441            pulseBuf[PULSE_ADR_LSB] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \   000010   0A4B         MOV.W   R11, R10
   \   000012   3A500600     ADD.W   #0x6, R10
   \   000016   E24A....     MOV.B   @R10, &pulseBuf + 1
    442            pulseBuf[PULSE_ADR_MSB] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   00001A   D24A0100.... MOV.B   0x1(R10), &pulseBuf + 2
    443          
    444            // 1st byte of message is skipped - CMD is always 0 for data.
    445            (void)osal_memcpy(pulseBuf+PULSE_DAT_OFF, msg->cmd.Data+1, PULSE_DAT_LEN-1);  //MHMS copies one buffer to another
   \   000020   3E401500     MOV.W   #0x15, R14
   \   000024   1D4B2400     MOV.W   0x24(R11), R13
   \   000028   1D53         ADD.W   #0x1, R13
   \   00002A   3C40....     MOV.W   #pulseBuf + 3, R12
   \   00002E   ........     CALLA   #osal_memcpy
    446          
    447            for (idx = PULSE_ADR_LSB; idx < PULSE_FCS_IDX; idx++)
   \   000032   5F43         MOV.B   #0x1, R15
    448            {
    449              fcs ^= pulseBuf[idx];
   \                     ??pulseDataRx_0:
   \   000034   58EF....     XOR.B   pulseBuf(R15), R8
    450            }
   \   000038   5F53         ADD.B   #0x1, R15
   \   00003A   7F901800     CMP.B   #0x18, R15
   \   00003E   FA2B         JNC     ??pulseDataRx_0
    451            pulseBuf[idx] = fcs;
   \   000040   CF48....     MOV.B   R8, pulseBuf(R15)
    452            
    453            uint8 deviceBPM;
    454            uint8 parentAddrLSB;
    455            uint8 parentAddrMSB;
    456            uint8 zsensorBuf[15];
    457            
    458            parentAddrLSB= pulseBuf[11];
   \   000044   5E42....     MOV.B   &pulseBuf + 11, R14
    459            parentAddrMSB= pulseBuf[12];  
   \   000048   5F42....     MOV.B   &pulseBuf + 12, R15
    460            
    461            if(pulseBuf[13] == CHECK_IN_INACTIVE){
   \   00004C   E293....     CMP.B   #0x2, &pulseBuf + 13
   \   000050   0320         JNE     ??pulseDataRx_2
    462            deviceBPM = pulseBuf[15];
   \   000052   5D42....     MOV.B   &pulseBuf + 15, R13
   \   000056   023C         JMP     ??pulseDataRx_3
    463            }
    464            else{
    465            deviceBPM = 5;
   \                     ??pulseDataRx_2:
   \   000058   7D400500     MOV.B   #0x5, R13
    466            }
    467            //deviceVolt = 0xFF;
    468            
    469            //Start of Frame Delimiter
    470            zsensorBuf[0]=0xFE;
   \                     ??pulseDataRx_3:
   \   00005C   ....         JMP     ?Subroutine0
   \   00005E   0343         NOP
    471            zsensorBuf[1]=10;
    472            zsensorBuf[2]=LO_UINT16(0x8746);
    473            zsensorBuf[3]=HI_UINT16(0x8746);
    474            
    475            //Source Address
    476            zsensorBuf[4] = LO_UINT16(msg->srcAddr.addr.shortAddr);
    477            zsensorBuf[5] = HI_UINT16(msg->srcAddr.addr.shortAddr);
    478            
    479            zsensorBuf[6]=LO_UINT16(2);  //MHMS are 6 - 9 being used for anything?
    480            zsensorBuf[7]=HI_UINT16(2);
    481            zsensorBuf[8]=LO_UINT16(4);
    482            zsensorBuf[9]=HI_UINT16(4);
    483            
    484            //Temperature and Voltage Data
    485            zsensorBuf[10]= deviceBPM;
    486            zsensorBuf[11]= deviceBPM; //deviceVolt;
    487            
    488            //Parent Address
    489            zsensorBuf[12]=parentAddrLSB;
    490            zsensorBuf[13]=parentAddrMSB;
    491          
    492          
    493            //FCS Check on the middle 13 bytes
    494            zsensorBuf[14] = calcFCS(&zsensorBuf[1], 13 );
    495          
    496            HalUARTWrite(PULSE_PORT, zsensorBuf, 15);  //For communicating with the Zigbee sensor Monitor
    497            
    498          /*  //MHMS USB communication with Pulse sensor Processor application
    499          
    500            uint8 BPMBuf[7] = {'B',0,0,0,10,13};
    501            uint8 IBIBuf[7] = {'Q',0,0,0,10,13};
    502            uint8 SignalBuf[7] = {'S',0,0,0,10,13};
    503            
    504            //conversion Signal Dec to ASCII
    505            uint16 temp = (BUILD_UINT16(pulseBuf[16], pulseBuf[17])) - 400;
    506            if(temp > 999){
    507              SignalBuf[1] = '9';
    508              SignalBuf[2] = '9';
    509              SignalBuf[3] = '9';
    510            }
    511            else { 
    512              SignalBuf[1] = (uint8)((temp/100)+ 48);
    513              SignalBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
    514              SignalBuf[3] = (uint8)(((temp % 100)%10)+ 48);
    515            }
    516            
    517            //conversion BPM Dec to ASCII
    518            temp = (uint16)pulseBuf[14];
    519            BPMBuf[1] = (uint8)((temp/100)+ 48);
    520            BPMBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
    521            BPMBuf[3] = (uint8)(((temp % 100)%10)+ 48);
    522            
    523            //conversion IBI Dec to ASCII
    524            temp = (uint16)pulseBuf[19];
    525            IBIBuf[1] = (uint8)((temp/100)+ 48);
    526            IBIBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
    527            IBIBuf[3] = (uint8)(((temp % 100)%10)+ 48);
    528             
    529          
    530            //HalUARTWrite(PULSE_PORT, SignalBuf, 6);
    531           // HalUARTWrite(PULSE_PORT, BPMBuf, 6);
    532           // HalUARTWrite(PULSE_PORT, IBIBuf, 6);
    533          */
    534          
    535          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   0B4C         MOV.W   R12, R11
   \   000002   4843         MOV.B   #0x0, R8
   \   000004   B290FEFF.... CMP.W   #0xfffe, &pulseAddr
   \   00000A   0620         JNE     ??pulseTestingDataRx_1
   \   00000C   3D400040     MOV.W   #0x4000, R13
   \   000010   5C42....     MOV.B   &pulseTaskId, R12
   \   000014   ........     CALLA   #osal_set_event
   \                     ??pulseTestingDataRx_1:
   \   000018   1001         RETA
    536          
    537          /**************************************************************************************************
    538           * @fn          pulseTestingDataRx
    539           *
    540           * @brief       This function is called by pulseAfMsgRx() to process incoming data  This is not used in 
    541           *              normal operation.  This is used for testing system with differnt payload sizes.
    542           * input parameters
    543           *
    544           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    545           *
    546           * output parameters
    547           *
    548           * None.
    549           *
    550           * @return      None.
    551           **************************************************************************************************
    552           */

   \                                 In  segment CODE, align 2, keep-with-next
    553          static void pulseTestingDataRx(afIncomingMSGPacket_t *msg)
   \                     pulseTestingDataRx:
    554          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   ........     CALLA   #?Subroutine3
    555             uint8 fcs = 0, idx;
    556            
    557             //uint8 *TestRxBuffer;
    558             //TestRxBuffer = (uint8*)osal_mem_alloc(MHMS_TEST_BUFF_LEN);
    559              
    560            
    561            // Last announce broadcast to stop must have expired before a parent could forward to a ZED.
    562            if (INVALID_NODE_ADDR == pulseAddr)
    563            {
    564              (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
    565            }
    566          
    567            TestRxBuffer[PULSE_SOP_IDX] = PULSE_SOP_VAL;
   \                     ??CrossCallReturnLabel_3:
   \   00000A   F240FE00.... MOV.B   #0xfe, &TestRxBuffer
    568            TestRxBuffer[PULSE_ADR_LSB] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \   000010   0A4B         MOV.W   R11, R10
   \   000012   3A500600     ADD.W   #0x6, R10
   \   000016   E24A....     MOV.B   @R10, &TestRxBuffer + 1
    569            TestRxBuffer[PULSE_ADR_MSB] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   00001A   D24A0100.... MOV.B   0x1(R10), &TestRxBuffer + 2
    570          
    571            // 1st byte of message is skipped - CMD is always 0 for data.
    572            (void)osal_memcpy(TestRxBuffer+PULSE_DAT_OFF, msg->cmd.Data+1, MHMS_TEST_PAYLOAD_LEN-1);  //MHMS copies one buffer to another
   \   000020   3E403100     MOV.W   #0x31, R14
   \   000024   1D4B2400     MOV.W   0x24(R11), R13
   \   000028   1D53         ADD.W   #0x1, R13
   \   00002A   3C40....     MOV.W   #TestRxBuffer + 3, R12
   \   00002E   ........     CALLA   #osal_memcpy
    573          
    574            for (idx = PULSE_ADR_LSB; idx < MHMS_FCS_IDX; idx++)
   \   000032   5F43         MOV.B   #0x1, R15
    575            {
    576              fcs ^= TestRxBuffer[idx];
   \                     ??pulseTestingDataRx_0:
   \   000034   58EF....     XOR.B   TestRxBuffer(R15), R8
    577            }
   \   000038   5F53         ADD.B   #0x1, R15
   \   00003A   7F903400     CMP.B   #0x34, R15
   \   00003E   FA2B         JNC     ??pulseTestingDataRx_0
    578            TestRxBuffer[idx] = fcs;
   \   000040   CF48....     MOV.B   R8, TestRxBuffer(R15)
    579            
    580            uint8 PktSeqNum; 
    581            
    582            uint8 parentAddrLSB;
    583            uint8 parentAddrMSB;
    584            uint8 tsensorBuf[15];
    585            
    586            parentAddrLSB= TestRxBuffer[11];
   \   000044   5E42....     MOV.B   &TestRxBuffer + 11, R14
    587            parentAddrMSB= TestRxBuffer[12];  
   \   000048   5F42....     MOV.B   &TestRxBuffer + 12, R15
    588            
    589            PktSeqNum = TestRxBuffer[13];
   \   00004C   5D42....     MOV.B   &TestRxBuffer + 13, R13
    590            
    591            //Start of Frame Delimiter
    592            tsensorBuf[0]=0xFE;
   \   000050                REQUIRE ?Subroutine0
   \   000050                // Fall through to label ?Subroutine0
    593            tsensorBuf[1]=10;
    594            tsensorBuf[2]=LO_UINT16(0x8746);
    595            tsensorBuf[3]=HI_UINT16(0x8746);
    596            
    597            //Source Address
    598            tsensorBuf[4] = LO_UINT16(msg->srcAddr.addr.shortAddr);
    599            tsensorBuf[5] = HI_UINT16(msg->srcAddr.addr.shortAddr);
    600            
    601            tsensorBuf[6]=LO_UINT16(2);  //MHMS are 6 - 9 being used for anything?
    602            tsensorBuf[7]=HI_UINT16(2);
    603            tsensorBuf[8]=LO_UINT16(4);
    604            tsensorBuf[9]=HI_UINT16(4);
    605            
    606            //Temperature and Voltage Data
    607            tsensorBuf[10]= PktSeqNum;
    608            tsensorBuf[11]= PktSeqNum; //deviceVolt;
    609            
    610            //Parent Address
    611            tsensorBuf[12]= parentAddrLSB;
    612            tsensorBuf[13]= parentAddrMSB;
    613          
    614          
    615            //FCS Check on the middle 13 bytes
    616            tsensorBuf[14] = calcFCS(&tsensorBuf[1], 13 );
    617          
    618            HalUARTWrite(PULSE_PORT, tsensorBuf, 15);  //For communicating with the Zigbee sensor Monitor
    619            
    620            //osal_mem_free(TestRxBuffer);
    621          }
    622          
    623          
    624          /**************************************************************************************************
    625           * @fn          pulseZdoStateChange 
    626           *
    627           * @brief       This function is called by pulseSysEvtMsg() for a ZDO_STATE_CHANGE message.
    628           *
    629           * input parameters
    630           *
    631           * None.
    632           *
    633           * output parameters
    634           *
    635           * None.
    636           *
    637           * @return      None.
    638           **************************************************************************************************
    639           */

   \                                 In  segment CODE, align 2
    640          static void pulseZdoStateChange(void)
   \                     pulseZdoStateChange:
    641          {
   \   000000   3B15         PUSHM.W #0x4, R11
    642            if(DEV_ZB_COORD == devState) 
   \   000002   5E42....     MOV.B   &devState, R14
   \   000006   7B400700     MOV.B   #0x7, R11
   \   00000A   3840....     MOV.W   #pulseTaskId, R8
   \   00000E   7E900900     CMP.B   #0x9, R14
   \   000012   2320         JNE     ??pulseZdoStateChange_0
    643            {
    644              (void)osal_stop_timerEx(pulseTaskId, PULSE_EVT_ANN);
   \   000014   3D400040     MOV.W   #0x4000, R13
   \   000018   6C48         MOV.B   @R8, R12
   \   00001A   ........     CALLA   #osal_stop_timerEx
    645          
    646              if ((DEV_ZB_COORD == devState) || (DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
   \   00001E   5E42....     MOV.B   &devState, R14
   \   000022   7E900900     CMP.B   #0x9, R14
   \   000026   0524         JEQ     ??pulseZdoStateChange_1
   \   000028   4E9B         CMP.B   R11, R14
   \   00002A   0324         JEQ     ??pulseZdoStateChange_1
   \   00002C   7E900600     CMP.B   #0x6, R14
   \   000030   6C20         JNE     ??pulseZdoStateChange_2
    647              {
    648          
    649                if (INVALID_NODE_ADDR == pulseAddr)
   \                     ??pulseZdoStateChange_1:
   \   000032   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_14:
   \   000036   0220         JNE     ??pulseZdoStateChange_3
    650                {
    651                pulseAddr = NWK_PAN_COORD_ADDR;
   \   000038   8243....     MOV.W   #0x0, &pulseAddr
    652                }
    653          
    654          
    655                if (INVALID_NODE_ADDR != pulseAddr)
    656                {
    657                  if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_ANN, PULSE_DLY_ANN))
   \                     ??pulseZdoStateChange_3:
   \   00003C   3E408813     MOV.W   #0x1388, R14
   \   000040   3D400040     MOV.W   #0x4000, R13
   \   000044   6C48         MOV.B   @R8, R12
   \   000046   ........     CALLA   #osal_start_timerEx
   \   00004A   4C93         CMP.B   #0x0, R12
   \   00004C   5E24         JEQ     ??pulseZdoStateChange_2
    658                  {
    659                    (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   \   00004E   3D400040     MOV.W   #0x4000, R13
   \   000052   6C48         MOV.B   @R8, R12
   \   000054   ........     CALLA   #osal_set_event
   \   000058   583C         JMP     ??pulseZdoStateChange_2
    660                  }
    661                }
    662              }
    663            }
    664            else if ((DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
   \                     ??pulseZdoStateChange_0:
   \   00005A   4E9B         CMP.B   R11, R14
   \   00005C   0324         JEQ     ??pulseZdoStateChange_4
   \   00005E   7E900600     CMP.B   #0x6, R14
   \   000062   5320         JNE     ??pulseZdoStateChange_2
    665            {
    666              (void)osal_stop_timerEx(pulseTaskId, PULSE_EVT_DAT);
   \                     ??pulseZdoStateChange_4:
   \   000064   3D400010     MOV.W   #0x1000, R13
   \   000068   6C48         MOV.B   @R8, R12
   \   00006A   ........     CALLA   #osal_stop_timerEx
    667              PulseEvtDat_sync = FALSE; //allow node to respond to Anounce commands to begin pulse collection
   \   00006E   C243....     MOV.B   #0x0, &PulseEvtDat_sync
    668          
    669                  if ((DEV_ROUTER == devState) || (DEV_END_DEVICE == devState)) //
   \   000072   C29B....     CMP.B   R11, &devState
   \   000076   0424         JEQ     ??pulseZdoStateChange_5
   \   000078   F2900600.... CMP.B   #0x6, &devState
   \   00007E   4520         JNE     ??pulseZdoStateChange_2
    670                  {
    671                    uint16 tmp = NLME_GetCoordShortAddr();
   \                     ??pulseZdoStateChange_5:
   \   000080   ........     CALLA   #NLME_GetCoordShortAddr
   \   000084   0A4C         MOV.W   R12, R10
    672                    uint8 dly = PULSE_STG_DAT;
   \   000086   ........     CALLA   #Onboard_rand
   \   00008A   3CB00080     BIT.W   #0x8000, R12
   \   00008E   4E7E         SUBC.B  R14, R14
   \   000090   5E53         ADD.B   #0x1, R14
    673          
    674                    pulseDat[PULSE_PAR_LSB] = LO_UINT16(tmp);
   \   000092   C24A....     MOV.B   R10, &pulseDat + 9
   \   000096   0F4A         MOV.W   R10, R15
   \   000098                RPT     #0x8
   \   000098   47190F10     RRUX.W  R15
   \   00009C   C24F....     MOV.B   R15, &pulseDat + 10
    675                    pulseDat[PULSE_PAR_MSB] = HI_UINT16(tmp);
    676                    
    677                    TestDatTx[PULSE_PAR_LSB] = LO_UINT16(tmp);
   \   0000A0   C24A....     MOV.B   R10, &TestDatTx + 9
    678                    TestDatTx[PULSE_PAR_MSB] = HI_UINT16(tmp);
   \   0000A4   C24F....     MOV.B   R15, &TestDatTx + 10
    679                    if ((DEV_ROUTER == devState) || (DEV_ZB_COORD == devState))
   \   0000A8   C29B....     CMP.B   R11, &devState
   \   0000AC   0424         JEQ     ??pulseZdoStateChange_6
   \   0000AE   F2900900.... CMP.B   #0x9, &devState
   \   0000B4   0720         JNE     ??pulseZdoStateChange_7
    680                    {
    681                      pulseDat[PULSE_TYP_IDX] |= 0x80;
   \                     ??pulseZdoStateChange_6:
   \   0000B6   F2D08000.... BIS.B   #0x80, &pulseDat + 19
    682                      TestDatTx[MHMS_TEST_PAYLOAD_LEN-3] |= 0x80;
   \   0000BC   F2D08000.... BIS.B   #0x80, &TestDatTx + 47
   \   0000C2   063C         JMP     ??pulseZdoStateChange_8
    683          
    684                    }
    685                    else
    686                    {
    687                      pulseDat[PULSE_TYP_IDX] &= (0xFF ^ 0x80);
   \                     ??pulseZdoStateChange_7:
   \   0000C4   F2C08000.... BIC.B   #0x80, &pulseDat + 19
    688                      TestDatTx[MHMS_TEST_PAYLOAD_LEN-3] &= (0xFF ^ 0x80);
   \   0000CA   F2C08000.... BIC.B   #0x80, &TestDatTx + 47
    689          
    690                    }
    691          
    692                #if TVSA_DONGLE_IS_ZC  //MHMS do we need this?
    693                    if (INVALID_NODE_ADDR == pulseAddr)
    694                    {
    695                      // Assume ZC is the TVSA Dongle until a TVSA_CMD_BEG gives a different address.
    696                      pulseAddr = NWK_PAN_COORD_ADDR;
    697                    }
    698                #endif
    699          
    700                    if (INVALID_NODE_ADDR != pulseAddr)
   \                     ??pulseZdoStateChange_8:
   \   0000D0   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_15:
   \   0000D4   0E24         JEQ     ??pulseZdoStateChange_9
    701                    {
    702                      if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_DAT, (dly + PULSE_DLY_MIN)))
   \   0000D6   3E508813     ADD.W   #0x1388, R14
   \   0000DA   3D400010     MOV.W   #0x1000, R13
   \   0000DE   6C48         MOV.B   @R8, R12
   \   0000E0   ........     CALLA   #osal_start_timerEx
   \   0000E4   4C93         CMP.B   #0x0, R12
   \   0000E6   0524         JEQ     ??pulseZdoStateChange_9
    703                      {
    704                        (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);
   \   0000E8   3D400010     MOV.W   #0x1000, R13
   \   0000EC   6C48         MOV.B   @R8, R12
   \   0000EE   ........     CALLA   #osal_set_event
    705                      }
    706                    }
    707          
    708          
    709                    if (0 == 0)
    710                    {
    711                      (void)osal_cpyExtAddr(pulseDat+PULSE_IEE_IDX, &aExtendedAddress);
   \                     ??pulseZdoStateChange_9:
   \   0000F2   3D40....     MOV.W   #znpIEEE, R13
   \   0000F6   3C40....     MOV.W   #pulseDat + 1, R12
   \   0000FA   ........     CALLA   #sAddrExtCpy
    712                      (void)osal_cpyExtAddr(TestDatTx+PULSE_IEE_IDX, &aExtendedAddress);
   \   0000FE   3D40....     MOV.W   #znpIEEE, R13
   \   000102   3C40....     MOV.W   #TestDatTx + 1, R12
   \   000106   ........     CALLA   #sAddrExtCpy
    713                    }
    714                  }
    715            }
    716               
    717              
    718          
    719          #if defined LCD_SUPPORTED
    720            HalLcdWriteValue(devState, 10, HAL_LCD_LINE_4);
   \                     ??pulseZdoStateChange_2:
   \   00010A   6F42         MOV.B   #0x4, R15
   \   00010C   7E400A00     MOV.B   #0xa, R14
   \   000110   5C42....     MOV.B   &devState, R12
   \   000114   0D43         MOV.W   #0x0, R13
   \   000116   ........     CALLA   #HalLcdWriteValue
    721          #endif
    722          }
   \   00011A   3817         POPM.W  #0x4, R11
   \   00011C   1001         RETA
    723          
    724          
    725          /**************************************************************************************************
    726           * @fn          pulseAnnce
    727           *
    728           * @brief       This function is called by pulseAppEvt() to send a TVSA announce to start or stop.
    729           *
    730           * input parameters
    731           *
    732           * None.
    733           *
    734           * output parameters
    735           *
    736           * None.
    737           *
    738           * @return      None.
    739           **************************************************************************************************
    740           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   3D400040     MOV.W   #0x4000, R13
   \   000004                REQUIRE ??Subroutine15_0
   \   000004                // Fall through to label ??Subroutine15_0

   \                                 In  segment CODE, align 2
    741          static void pulseAnnce(void)
   \                     pulseAnnce:
    742          {
   \   000000   31801000     SUB.W   #0x10, SP
    743            uint8 msg[3];
    744            afAddrType_t addr;
    745            
    746            addr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
   \   000004   B1430400     MOV.W   #0xffff, 0x4(SP)
    747            addr.addrMode = afAddrBroadcast;
   \   000008   F1400F000C00 MOV.B   #0xf, 0xc(SP)
    748            addr.endPoint = PULSE_ENDPOINT;
   \   00000E   F14003000D00 MOV.B   #0x3, 0xd(SP)
    749          
    750            if (INVALID_NODE_ADDR != pulseAddr)
   \   000014   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_13:
   \   000018   0F24         JEQ     ??pulseAnnce_0
    751            {
    752              msg[PULSE_CMD_IDX] = PULSE_CMD_BEG;
   \   00001A   D1430000     MOV.B   #0x1, 0(SP)
    753              if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_ANN, PULSE_DLY_ANN))
   \   00001E   3E408813     MOV.W   #0x1388, R14
   \   000022   3D400040     MOV.W   #0x4000, R13
   \   000026   5C42....     MOV.B   &pulseTaskId, R12
   \   00002A   ........     CALLA   #osal_start_timerEx
   \   00002E   4C93         CMP.B   #0x0, R12
   \   000030   0524         JEQ     ??pulseAnnce_1
    754              {
    755                (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   \   000032   ........     CALLA   #?Subroutine9
    756              }
    757            }
   \                     ??CrossCallReturnLabel_29:
   \   000036   023C         JMP     ??pulseAnnce_1
    758            else
    759            {
    760              msg[PULSE_CMD_IDX] = PULSE_CMD_END;
   \                     ??pulseAnnce_0:
   \   000038   E1430000     MOV.B   #0x2, 0(SP)
    761            }
    762          
    763            msg[PULSE_ADR_LSB] = LO_UINT16(pulseAddr);
   \                     ??pulseAnnce_1:
   \   00003C   D142....0100 MOV.B   &pulseAddr, 0x1(SP)
    764            msg[PULSE_ADR_MSB] = HI_UINT16(pulseAddr);
   \   000042   D142....0200 MOV.B   &pulseAddr + 1, 0x2(SP)
    765          
    766            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
    767                                                    3, msg, &pulseTSN, AF_TX_OPTIONS_NONE, AF_DEFAULT_RADIUS))
   \   000048   70121E00     PUSH.B  #0x1e
   \   00004C   4312         PUSH.B  #0x0
   \   00004E   3012....     PUSH.W  #pulseTSN
   \   000052   0F41         MOV.W   SP, R15
   \   000054   3F500600     ADD.W   #0x6, R15
   \   000058   0F12         PUSH.W  R15
   \   00005A   3F400300     MOV.W   #0x3, R15
   \   00005E   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_26:
   \   000062   ........     CALLA   #AF_DataRequest
   \   000066   3152         ADD.W   #0x8, SP
   \   000068   4C93         CMP.B   #0x0, R12
   \   00006A   0324         JEQ     ??pulseAnnce_2
    768            {
    769              osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   \   00006C   ........     CALLA   #?Subroutine9
    770            }
   \                     ??CrossCallReturnLabel_28:
   \   000070   023C         JMP     ??pulseAnnce_3
    771            else
    772            {
    773              pulseCnt++;
   \                     ??pulseAnnce_2:
   \   000072   9253....     ADD.W   #0x1, &pulseCnt
    774            }
    775          }
   \                     ??pulseAnnce_3:
   \   000076   31501000     ADD.W   #0x10, SP
   \   00007A   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine12:
   \   000000   2E43         MOV.W   #0x2, R14
   \   000002   3D40....     MOV.W   #PULSE_epDesc, R13
   \   000006   0C41         MOV.W   SP, R12
   \   000008   3C501000     ADD.W   #0x10, R12
   \   00000C   1001         RETA
    776          
    777          
    778          /**************************************************************************************************
    779           * @fn          pulseDataCalc
    780           *
    781           * @brief       This function is called by pulseAppEvt() to calculate the data for a PULSE report.
    782           *              The function will called on a 2ms interval and detect whether a pulse is being measured.
    783           *              If a pulse is determined it will invoke the PulsedataReq interrupt timer (20ms intervals)
    784           *
    785           * input parameters
    786           *
    787           * None.
    788           *
    789           * output parameters
    790           *
    791           * None.
    792           *
    793           * @return      None.
    794           **************************************************************************************************
    795           */

   \                                 In  segment CODE, align 2
    796          static void pulseDataCalc(void)
   \                     pulseDataCalc:
    797          {
   \   000000   0A12         PUSH.W  R10
    798            PulseEvtDat_sync = TRUE;      //Pulse Data collection has been synced, no need to respond to annc commands to set EVT
   \   000002   D243....     MOV.B   #0x1, &PulseEvtDat_sync
    799            
    800            if (INVALID_NODE_ADDR == pulseAddr)
   \   000006   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_12:
   \   00000A   2824         JEQ     ??pulseDataCalc_0
    801            {
    802              return;
    803            }
    804            
    805            if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_DAT, PULSE_DLY_DAT))  //If the timer can't be started set event flag again for it to be service again
   \   00000C   3A40....     MOV.W   #pulseTaskId, R10
   \   000010   2E43         MOV.W   #0x2, R14
   \   000012   3D400010     MOV.W   #0x1000, R13
   \   000016   6C4A         MOV.B   @R10, R12
   \   000018   ........     CALLA   #osal_start_timerEx
   \   00001C   4C93         CMP.B   #0x0, R12
   \   00001E   0424         JEQ     ??pulseDataCalc_1
    806            {
    807              (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);
   \   000020   3D400010     MOV.W   #0x1000, R13
   \   000024   ........     CALLA   #?Subroutine6
    808            }
    809            pulseBPM(pulseDat);  //Function to collect/calculate Pulse
   \                     ??pulseDataCalc_1:
   \   000028   3C40....     MOV.W   #pulseDat, R12
   \   00002C   ........     CALLA   #pulseBPM
    810          
    811          #if TVSA_DATA_CNF
    812            pulseDat[PULSE_RTG_IDX] = pulseCnfErrCnt;
    813          #else
    814            pulseDat[PULSE_RTG_IDX] = 0;
   \   000030   C243....     MOV.B   #0x0, &pulseDat + 21
    815          #endif
    816          
    817            if(QS == TRUE && PulseEvtReq_sync == FALSE){//If pulse is being measured synchronize pulsedatareq event
   \   000034   D293....     CMP.B   #0x1, &QS
   \   000038   0820         JNE     ??pulseDataCalc_2
   \   00003A   C293....     CMP.B   #0x0, &PulseEvtReq_sync
   \   00003E   0520         JNE     ??pulseDataCalc_2
    818            osal_set_event(pulseTaskId, PULSE_EVT_REQ);
   \   000040   3D400020     MOV.W   #0x2000, R13
   \   000044   ........     CALLA   #?Subroutine6
    819              }  
   \                     ??CrossCallReturnLabel_8:
   \   000048   093C         JMP     ??pulseDataCalc_0
    820            else if(PulseEvtCheckin_sync == FALSE)
   \                     ??pulseDataCalc_2:
   \   00004A   C293....     CMP.B   #0x0, &PulseEvtCheckin_sync
   \   00004E   0620         JNE     ??pulseDataCalc_0
    821            {
    822            osal_set_event(pulseTaskId, PULSE_EVT_CHECKIN);  //Since no pulse data is being collect, just send check in data to coordinator
   \   000050   3D400008     MOV.W   #0x800, R13
   \   000054   ........     CALLA   #?Subroutine6
    823            PulseEvtCheckin_sync = TRUE;
   \                     ??CrossCallReturnLabel_7:
   \   000058   D243....     MOV.B   #0x1, &PulseEvtCheckin_sync
   \                     ??pulseDataCalc_0:
   \   00005C   3A41         POP.W   R10
   \   00005E   1001         RETA
    824            }
    825           
    826          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   6C4A         MOV.B   @R10, R12
   \   000002   ........     BRA     #osal_set_event
    827          
    828          /**************************************************************************************************
    829           * @fn          pulseBPM
    830           *
    831           * @brief       This function is called by pulseDataCalc().  This function contains the main algorithm for pulse calculation.
    832           *
    833           *
    834           * input parameters
    835           *
    836           * Pointer to the pulsedata array that will be sent over the air.
    837           *
    838           * output parameters
    839           *
    840           * None.
    841           *
    842           * @return      None.
    843           **************************************************************************************************/

   \                                 In  segment CODE, align 2
    844          static void pulseBPM(uint8 *pulsedata)
   \                     pulseBPM:
    845          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0A4C         MOV.W   R12, R10
    846          
    847          //MHMS 
    848          //MHMS From arduino interrupt
    849          static volatile int rate[10];                    // used to hold last ten IBI values
    850          static volatile uint32 sampleCounter = 0;          // used to determine pulse timing
    851          static volatile uint32 lastBeatTime = 0;           // used to find the inter beat interval
    852          static volatile int P = 512;                      // used to find peak in pulse wave
    853          static volatile int T = 512;                     // used to find trough in pulse wave
    854          static volatile int thresh = 512;                // used to find instant moment of heart beat
    855          static volatile int amp = 100;                   // used to hold amplitude of pulse waveform
    856          static volatile bool firstBeat = TRUE;        // used to seed rate array so we startup with reasonable BPM
    857          static volatile bool secondBeat = TRUE;       // used to seed rate array so we startup with reasonable BPM
    858            
    859          int BPM = pulsedata[PULSE_BPM];                         // used to hold the pulse rate
   \   000004   574C0D00     MOV.B   0xd(R12), R7
    860          int Signal;                                             // holds the incoming raw data
    861          int IBI = pulsedata[PULSE_IBI];                         // holds the time between beats, the Inter-Beat Interval
   \   000008   584C1200     MOV.B   0x12(R12), R8
    862          
    863          //    cli();                                            // disable interrupts while we do this
    864          //    Signal = analogRead(pulsePin);                    // read the Pulse Sensor  //MHMS orginal arduino code
    865          
    866          //MHMS using HAL layer API to set channel to read and 10 Bit resolution
    867            Signal = HalAdcRead(HAL_ADC_CHANNEL_7, HAL_ADC_RESOLUTION_10);
   \   00000C   6D43         MOV.B   #0x2, R13
   \   00000E   7C400700     MOV.B   #0x7, R12
   \   000012   ........     CALLA   #HalAdcRead
   \   000016   0B4C         MOV.W   R12, R11
    868            
    869            sampleCounter += 2;                                   // keep track of the time in mS with this variable
   \   000018   A253....     ADD.W   #0x2, &??sampleCounter
   \   00001C   8263....     ADDC.W  #0x0, &??sampleCounter + 2
    870            int Number = (sampleCounter - lastBeatTime);          // monitor the time since the last beat to avoid noise
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000020   3440....     MOV.W   #??sampleCounter, R4
   \   000024   2644         MOV.W   @R4, R6
   \   000026   1682....     SUB.W   &??lastBeatTime, R6
    871          
    872          //  find the peak and trough of the pulse wave
    873              if(Signal < thresh && Number > (IBI/5)*3){          // avoid dichrotic noise by waiting 3/5 of last IBI
   \   00002A   3940....     MOV.W   #??thresh, R9
   \   00002E   2C99         CMP.W   @R9, R12
   \   000030   0834         JGE     ??pulseBPM_2
   \   000032   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_10:
   \   000036   0534         JGE     ??pulseBPM_2
    874                  if (Signal < T){                                // T is the trough
   \   000038   1B92....     CMP.W   &??T, R11
   \   00003C   0234         JGE     ??pulseBPM_2
    875                      T = Signal;                                 // keep track of lowest point in pulse wave 
   \   00003E   824B....     MOV.W   R11, &??T
    876                   }
    877                 }
    878                
    879              if(Signal > thresh && Signal > P){          // thresh condition helps avoid noise
   \                     ??pulseBPM_2:
   \   000042   829B....     CMP.W   R11, &??thresh
   \   000046   0534         JGE     ??pulseBPM_3
   \   000048   829B....     CMP.W   R11, &??P
   \   00004C   0234         JGE     ??pulseBPM_3
    880                  P = Signal;                             // P is the peak
   \   00004E   824B....     MOV.W   R11, &??P
    881                 }                                        // keep track of highest point in pulse wave
    882              
    883            //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
    884            // signal surges up in value every time there is a pulse
    885          if (Number > 250){                                   // avoid high frequency noise //MHMS increased from 250 to 500 to reduce high freq noise
   \                     ??pulseBPM_3:
   \   000052   3690FB00     CMP.W   #0xfb, R6
   \   000056   5E38         JL      ??pulseBPM_4
    886            if ((Signal > thresh) && (Pulse == FALSE) && (Number > (int)(IBI/5)*3) ){        
   \   000058   829B....     CMP.W   R11, &??thresh
   \   00005C   5B34         JGE     ??pulseBPM_4
   \   00005E   C293....     CMP.B   #0x0, &Pulse
   \   000062   5820         JNE     ??pulseBPM_4
   \   000064   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_11:
   \   000068   5534         JGE     ??pulseBPM_4
    887              Pulse = TRUE;                               // set the Pulse flag when we think there is a pulse
   \   00006A   D243....     MOV.B   #0x1, &Pulse
    888              
    889              //MHMS  could define some external LED or just write to LCD screen "Pulse found"
    890              HalLedSet (HAL_LED_2, HAL_LED_MODE_OFF);    //MHMS beat found
   \   00006E   4D43         MOV.B   #0x0, R13
   \   000070   6C43         MOV.B   #0x2, R12
   \   000072   ........     CALLA   #HalLedSet
    891              HalLedSet (HAL_LED_1, HAL_LED_MODE_ON);     //MHMS LED on during upbeat
   \   000076   5D43         MOV.B   #0x1, R13
   \   000078   5C43         MOV.B   #0x1, R12
   \   00007A   ........     CALLA   #HalLedSet
    892              
    893              IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00007E   2844         MOV.W   @R4, R8
   \   000080   1882....     SUB.W   &??lastBeatTime, R8
    894              lastBeatTime = sampleCounter;               // keep track of time for next pulse
   \   000084   A244....     MOV.W   @R4, &??lastBeatTime
   \   000088   92440200.... MOV.W   0x2(R4), &??lastBeatTime + 2
    895                   
    896                   if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE
   \   00008E   C293....     CMP.B   #0x0, &??firstBeat
   \   000092   0324         JEQ     ??pulseBPM_5
    897                       firstBeat = FALSE;                 // clear firstBeat flag
   \   000094   C243....     MOV.B   #0x0, &??firstBeat
    898                       return;                            // IBI value is unreliable so discard it
   \   000098   8B3C         JMP     ??pulseBPM_6
    899                      }   
    900                   if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
   \                     ??pulseBPM_5:
   \   00009A   C293....     CMP.B   #0x0, &??secondBeat
   \   00009E   0B24         JEQ     ??pulseBPM_7
    901                      secondBeat = FALSE;                 // clear secondBeat flag
   \   0000A0   C243....     MOV.B   #0x0, &??secondBeat
    902                         for(int i=0; i<=9; i++){         // seed the running total to get a realisitic BPM at startup
   \   0000A4   0743         MOV.W   #0x0, R7
    903                              rate[i] = IBI;                      
   \                     ??pulseBPM_0:
   \   0000A6   0F47         MOV.W   R7, R15
   \   0000A8   0F5F         RLA.W   R15
   \   0000AA   8F48....     MOV.W   R8, ??rate(R15)
    904                              }
   \   0000AE   1753         ADD.W   #0x1, R7
   \   0000B0   37900A00     CMP.W   #0xa, R7
   \   0000B4   F83B         JL      ??pulseBPM_0
    905                      }
    906                    
    907              // keep a running total of the last 10 IBI values
    908              int16 runningTotal = 0; //word runningTotal = 0;                   // clear the runningTotal variable    
   \                     ??pulseBPM_7:
   \   0000B6   0F43         MOV.W   #0x0, R15
    909          
    910              for(int i=0; i<=8; i++){                // shift data in the rate array
   \   0000B8   0743         MOV.W   #0x0, R7
    911                    rate[i] = rate[i+1];              // and drop the oldest IBI value 
   \                     ??pulseBPM_1:
   \   0000BA   0E47         MOV.W   R7, R14
   \   0000BC   0E5E         RLA.W   R14
   \   0000BE   9E4E........ MOV.W   ??rate + 2(R14), ??rate(R14)
    912                    runningTotal += rate[i];          // add up the 9 oldest IBI values
   \   0000C4   1F5E....     ADD.W   ??rate(R14), R15
    913                  }
   \   0000C8   1753         ADD.W   #0x1, R7
   \   0000CA   37900900     CMP.W   #0x9, R7
   \   0000CE   F53B         JL      ??pulseBPM_1
    914                  
    915              rate[9] = IBI;                          // add the latest IBI to the rate array
   \   0000D0   8248....     MOV.W   R8, &??rate + 18
    916              runningTotal += rate[9];                // add the latest IBI to runningTotal
    917              runningTotal /= 10;                     // average the last 10 IBI values 
    918              BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
   \   0000D4   3C4060EA     MOV.W   #0xea60, R12
   \   0000D8   0312         PUSH.W  #0x0
   \   0000DA   0C12         PUSH.W  R12
   \   0000DC   1F52....     ADD.W   &??rate + 18, R15
   \   0000E0   0C4F         MOV.W   R15, R12
   \   0000E2   3E400A00     MOV.W   #0xa, R14
   \   0000E6   ........     CALLA   #?DivMod16s
   \   0000EA   0E4C         MOV.W   R12, R14
   \   0000EC   0F4C         MOV.W   R12, R15
   \   0000EE   3FE3         XOR.W   #0xffff, R15
   \   0000F0   0F5F         RLA.W   R15
   \   0000F2   0F7F         SUBC.W  R15, R15
   \   0000F4   3C41         POP.W   R12
   \   0000F6   3D41         POP.W   R13
   \   0000F8   ........     CALLA   #?DivMod32s
   \   0000FC   474C         MOV.B   R12, R7
    919              QS = TRUE;                              // set Quantified Self flag //MHMS we will use this to flag other event to transmit data over network
   \   0000FE   D243....     MOV.B   #0x1, &QS
    920              
    921          
    922              HalLcdWriteStringValue("BPM:",BPM, 10, HAL_LCD_LINE_5); //MHMS display BPM on LCD screen
   \   000102   7F400500     MOV.B   #0x5, R15
   \   000106   7E400A00     MOV.B   #0xa, R14
   \   00010A   0D4C         MOV.W   R12, R13
   \   00010C   3C40....     MOV.W   #`?<Constant "BPM:">`, R12
   \   000110   ........     CALLA   #HalLcdWriteStringValue
    923              }                       
    924          }
    925          
    926            if (Signal < thresh && Pulse == TRUE){     // when the values are going down, the beat is over
   \                     ??pulseBPM_4:
   \   000114   2B99         CMP.W   @R9, R11
   \   000116   1E34         JGE     ??pulseBPM_8
   \   000118   D293....     CMP.B   #0x1, &Pulse
   \   00011C   1B20         JNE     ??pulseBPM_8
    927                //digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
    928               //MHMS  could define some external LED or just write to LCD screen "Pulse Not found"
    929                HalLedSet (HAL_LED_1, HAL_LED_MODE_OFF);
   \   00011E   4D43         MOV.B   #0x0, R13
   \   000120   5C43         MOV.B   #0x1, R12
   \   000122   ........     CALLA   #HalLedSet
    930                
    931                Pulse = FALSE;                         // reset the Pulse flag so we can do it again
   \   000126   C243....     MOV.B   #0x0, &Pulse
    932                amp = P - T;                           // get amplitude of the pulse wave
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00012A   1F42....     MOV.W   &??P, R15
   \   00012E   1F82....     SUB.W   &??T, R15
   \   000132   824F....     MOV.W   R15, &??amp
    933                thresh = amp/2 + T + 100;              // set thresh at 50% of the amplitude  //MHMS offset up by 100 to ignore small flucuations due to noise
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000136   1C42....     MOV.W   &??amp, R12
   \   00013A   2E43         MOV.W   #0x2, R14
   \   00013C   ........     CALLA   #?DivMod16s
   \   000140   1C52....     ADD.W   &??T, R12
   \   000144   3C506400     ADD.W   #0x64, R12
   \   000148   824C....     MOV.W   R12, &??thresh
    934                P = thresh;                            // reset these for next time
   \   00014C   A249....     MOV.W   @R9, &??P
    935                T = thresh;
   \   000150   A249....     MOV.W   @R9, &??T
    936               }
    937            
    938            if (Number > 2500){                        // if 2.5 seconds go by without a beat
   \                     ??pulseBPM_8:
   \   000154   3690C509     CMP.W   #0x9c5, R6
   \   000158   1738         JL      ??pulseBPM_9
    939                HalLedSet (HAL_LED_2, HAL_LED_MODE_ON);// MHMS Indicate that no beat found
   \   00015A   5D43         MOV.B   #0x1, R13
   \   00015C   6C43         MOV.B   #0x2, R12
   \   00015E   ........     CALLA   #HalLedSet
    940                thresh = 512 + 100;                    // set thresh default //MHMS offset up by 100 to ignore small flucuations due to noise
   \   000162   B2406402.... MOV.W   #0x264, &??thresh
    941                P = 512;                               // set P default
   \   000168   B2400002.... MOV.W   #0x200, &??P
    942                T = 512;                               // set T default
   \   00016E   B2400002.... MOV.W   #0x200, &??T
    943                lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date        
   \   000174   B244....     MOV.W   @R4+, &??lastBeatTime
   \   000178   B244....     MOV.W   @R4+, &??lastBeatTime + 2
    944                firstBeat = TRUE;                      // set these to avoid noise
   \   00017C   D243....     MOV.B   #0x1, &??firstBeat
    945                secondBeat = TRUE;                     // when we get the heartbeat back
   \   000180   D243....     MOV.B   #0x1, &??secondBeat
    946                QS = FALSE;                            // Clears Pulse measurement quantifier flag so no data  is sent over the air
   \   000184   C243....     MOV.B   #0x0, &QS
    947               }
    948          
    949          //MHMS Loading 16 bit results into 8 bit blocks for pulsedata array              
    950          pulsedata[PULSE_BPM] = (uint8)((BPM & 0x00FF));
   \                     ??pulseBPM_9:
   \   000188   CA470D00     MOV.B   R7, 0xd(R10)
    951          pulsedata[PULSE_RAW_MSB] = (uint8)((Signal >> 8));
   \   00018C   0F4B         MOV.W   R11, R15
   \   00018E                RPT     #0x8
   \   00018E   47180F11     RRAX.W  R15
   \   000192   CA4F1000     MOV.B   R15, 0x10(R10)
    952          pulsedata[PULSE_RAW_LSB] = (uint8)((Signal & 0x00FF));
   \   000196   CA4B0F00     MOV.B   R11, 0xf(R10)
    953          pulsedata[PULSE_IBI] = (uint8)((IBI & 0x00FF));
   \   00019A   CA481200     MOV.B   R8, 0x12(R10)
    954          
    955          pulsedata[PULSE_BPM_CHAR] = 'B';
   \   00019E   FA4042000C00 MOV.B   #0x42, 0xc(R10)
    956          pulsedata[PULSE_RAW_CHAR] = 'S';
   \   0001A4   FA4053000E00 MOV.B   #0x53, 0xe(R10)
    957          pulsedata[PULSE_IBI_CHAR] = 'Q';
   \   0001AA   FA4051001100 MOV.B   #0x51, 0x11(R10)
    958          
    959          //HalLcdWriteStringValue("Signal:",Signal, 10, 7); //MHMS  for testing ADC values
    960          
    961          
    962            //sei();                                     // enable interrupts when youre done!
    963          }// end isr
   \                     ??pulseBPM_6:
   \   0001B0   7417         POPM.W  #0x8, R11
   \   0001B2   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine10:
   \   000000   4C48         MOV.B   R8, R12
   \   000002   7E400500     MOV.B   #0x5, R14
   \   000006   ........     CALLA   #?DivMod8u
   \   00000A   4C4C         MOV.B   R12, R12
   \   00000C   0F4C         MOV.W   R12, R15
   \   00000E                RPT     #0x2
   \   00000E   41180F5C     ADDX.W  R12, R15
   \   000012   0F96         CMP.W   R6, R15
   \   000014   1001         RETA

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??rate:
   \   000000                DS8 20

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??sampleCounter:
   \   000000                DS8 4

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??lastBeatTime:
   \   000000                DS8 4

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??P:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for P>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??T:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for T>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??thresh:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for thresh>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??amp:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for amp>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??firstBeat:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for firstBeat>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??secondBeat:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for secondBeat>`
    964          
    965          /**************************************************************************************************
    966           * @fn          pulseDataReq
    967           *
    968           * @brief       This function is called by pulseAppEvt() to send a PULSE data report. When it is detected that
    969           *              a pulse is found (QS flag is set) this function will start to transfer BPM, IBI, and raw Signal
    970           *              data over the air to the coordinator at 20ms intervals. When there is no BPM detected
    971           *              this function will stop sending information over the air to the coordinator.
    972           *
    973           * input parameters
    974           *
    975           * None.
    976           *
    977           * output parameters
    978           *
    979           * None.
    980           *
    981           * @return      None.
    982           **************************************************************************************************
    983           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   31500C00     ADD.W   #0xc, SP
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   3F401600     MOV.W   #0x16, R15
   \   000004                REQUIRE ??Subroutine14_0
   \   000004                // Fall through to label ??Subroutine14_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine14_0:
   \   000000   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_27:
   \   000004   ........     BRA     #AF_DataRequest

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   9142....0400 MOV.W   &pulseAddr, 0x4(SP)
   \   000006   E1430C00     MOV.B   #0x2, 0xc(SP)
   \   00000A   F14003000D00 MOV.B   #0x3, 0xd(SP)
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
    984          static void pulseDataReq(void)
   \                     pulseDataReq:
    985          {
   \   000000   31800C00     SUB.W   #0xc, SP
    986            static bool pulseDataReqFlag;
    987            pulseDataReqFlag = FALSE;
   \   000004   C243....     MOV.B   #0x0, &??pulseDataReqFlag
    988            afAddrType_t addr;                    //AF address stucture defined for info on the destination Endpoint object that data will be sent to
    989            
    990            osal_stop_timerEx(pulseTaskId, PULSE_EVT_CHECKIN);  //Node is collecting data and sending it to coordinator so turn off check in event
   \   000008   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_19:
   \   00000C   ........     CALLA   #osal_stop_timerEx
    991            PulseEvtCheckin_sync = FALSE;  
   \   000010   C243....     MOV.B   #0x0, &PulseEvtCheckin_sync
    992            
    993            pulseDat[PULSE_CHECK_IN] = CHECK_IN_INACTIVE;   //Flag is off and will notify coordinator that node is not sending check in data
   \   000014   E243....     MOV.B   #0x2, &pulseDat + 11
    994           
    995            addr.addr.shortAddr = pulseAddr;      //loading short address (16-bit) with pulse address
   \   000018   ........     CALLA   #?Subroutine2
    996            addr.addrMode = afAddr16Bit;          //Set to directly sent to a node
    997            addr.endPoint = PULSE_ENDPOINT;       //Sets the endpoint of the final destination (coordinator?)
    998          
    999            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
   1000                                                    PULSE_DAT_LEN, pulseDat, &pulseTSN,
   1001                                                    AF_DISCV_ROUTE
   1002          #if TVSA_DATA_CNF
   1003                                                  | AF_ACK_REQUEST
   1004          #endif
   1005                                                   ,AF_DEFAULT_RADIUS))  //MHMS
   \                     ??CrossCallReturnLabel_2:
   \   00001C   70121E00     PUSH.B  #0x1e
   \   000020   70122000     PUSH.B  #0x20
   \   000024   3012....     PUSH.W  #pulseTSN
   \   000028   3012....     PUSH.W  #pulseDat
   \   00002C   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_24:
   \   000030   3152         ADD.W   #0x8, SP
   \   000032   4C93         CMP.B   #0x0, R12
   \   000034   0524         JEQ     ??pulseDataReq_0
   1006            { //if data transfer is unsuccessful place event immediately back into queue to attempt to send again
   1007                  osal_set_event(pulseTaskId, PULSE_EVT_REQ);
   \   000036   ........     CALLA   #?Subroutine7
   1008            }
   \                     ??CrossCallReturnLabel_21:
   \   00003A   ........     CALLA   #osal_set_event
   \   00003E   023C         JMP     ??pulseDataReq_1
   1009            else
   1010            {
   1011              pulseCnt++;
   \                     ??pulseDataReq_0:
   \   000040   9253....     ADD.W   #0x1, &pulseCnt
   1012            }
   1013            if((QS == TRUE) && (pulseDataReqFlag == FALSE)){
   \                     ??pulseDataReq_1:
   \   000044   D293....     CMP.B   #0x1, &QS
   \   000048   0B20         JNE     ??pulseDataReq_2
   \   00004A   C293....     CMP.B   #0x0, &??pulseDataReqFlag
   \   00004E   0820         JNE     ??pulseDataReq_2
   1014              osal_start_timerEx(pulseTaskId, PULSE_EVT_REQ, PULSE_DLY_DATAREQ);  //send next Pulse data report in 20ms
   \   000050   3E401400     MOV.W   #0x14, R14
   \   000054   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_22:
   \   000058   ........     CALLA   #osal_start_timerEx
   1015              pulseDataReqFlag = TRUE;  //to prevent restarting of timer if existing already running
   \   00005C   D243....     MOV.B   #0x1, &??pulseDataReqFlag
   1016               
   1017            }
   1018            /*
   1019          
   1020            //MHMS USB communication with Pulse sensor Processor application
   1021          
   1022            uint8 BPMBuf[7] = {'B',0,0,0,10,13};
   1023            uint8 IBIBuf[7] = {'Q',0,0,0,10,13};
   1024            uint8 SignalBuf[7] = {'S',0,0,0,10,13};
   1025            
   1026            //conversion Signal Dec to ASCII
   1027            uint16 temp = (BUILD_UINT16(pulseDat[15], pulseDat[16])) - 400;
   1028            if(temp > 999){
   1029              SignalBuf[1] = '9';
   1030              SignalBuf[2] = '9';
   1031              SignalBuf[3] = '9';
   1032            }
   1033            else { 
   1034              SignalBuf[1] = (uint8)((temp/100)+ 48);
   1035              SignalBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
   1036              SignalBuf[3] = (uint8)(((temp % 100)%10)+ 48);
   1037            }
   1038            
   1039            //conversion BPM Dec to ASCII
   1040            temp = (uint16)pulseDat[13];
   1041            BPMBuf[1] = (uint8)((temp/100)+ 48);
   1042            BPMBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
   1043            BPMBuf[3] = (uint8)(((temp % 100)%10)+ 48);
   1044            
   1045            //conversion IBI Dec to ASCII
   1046            temp = (uint16)pulseDat[18];
   1047            IBIBuf[1] = (uint8)((temp/100)+ 48);
   1048            IBIBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
   1049            IBIBuf[3] = (uint8)(((temp % 100)%10)+ 48);
   1050             
   1051            
   1052            HalUARTWrite(0, SignalBuf, 6);
   1053            HalUARTWrite(0, BPMBuf, 6);
   1054            HalUARTWrite(0, IBIBuf, 6);
   1055            */
   1056          }
   \                     ??pulseDataReq_2:
   \   000060   ....         JMP     ?Subroutine1
   \   000062   0343         NOP

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   3D400020     MOV.W   #0x2000, R13
   \   000004                REQUIRE ?Subroutine13
   \   000004                // Fall through to label ?Subroutine13

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   5C42....     MOV.B   &pulseTaskId, R12
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   3D400008     MOV.W   #0x800, R13
   \   000004   ....         JMP     ?Subroutine13
   \   000006   0343         NOP

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??pulseDataReqFlag:
   \   000000                DS8 1
   1057          
   1058          
   1059          /**************************************************************************************************
   1060           * @fn          pulseNodeCheckIn
   1061           *
   1062           * @brief       This function is called by the pulseAppEvt() function.  
   1063           *
   1064           * input parameters
   1065           *
   1066           *
   1067           * output parameters
   1068           *
   1069           * None.
   1070           *
   1071           * @return      None.
   1072           **************************************************************************************************
   1073           */
   1074          

   \                                 In  segment CODE, align 2, keep-with-next
   1075          static void pulseNodeCheckIn(void)
   \                     pulseNodeCheckIn:
   1076          {
   \   000000   31800C00     SUB.W   #0xc, SP
   1077          
   1078            static bool Flag;
   1079            afAddrType_t addr;                    //AF address stucture defined for info on the destination Endpoint object that data will be sent to
   1080            
   1081            osal_stop_timerEx(pulseTaskId, PULSE_EVT_REQ); //Stop pulseDataReq() task since no pulse data is being measured
   \   000004   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_20:
   \   000008   ........     CALLA   #osal_stop_timerEx
   1082            PulseEvtReq_sync = FALSE;
   \   00000C   C243....     MOV.B   #0x0, &PulseEvtReq_sync
   1083            Flag = FALSE;
   \   000010   C243....     MOV.B   #0x0, &??Flag
   1084            addr.addr.shortAddr = pulseAddr;      //loading short address (16-bit) with pulse address
   \   000014   ........     CALLA   #?Subroutine2
   1085            addr.addrMode = afAddr16Bit;          //Set to directly sent to a node
   1086            addr.endPoint = PULSE_ENDPOINT;       //Sets the endpoint of the final destination (coordinator?)
   1087          
   1088            pulseDat[PULSE_CHECK_IN] = CHECK_IN_ACTIVE;   //Flag is set and will notify coordinator that node is currently sending check in data
   \                     ??CrossCallReturnLabel_1:
   \   000018   D243....     MOV.B   #0x1, &pulseDat + 11
   1089            HalLcdWriteString("BPMsensor Inacti",HAL_LCD_LINE_5);
   \   00001C   7D400500     MOV.B   #0x5, R13
   \   000020   3C40....     MOV.W   #`?<Constant "BPMsensor Inacti">`, R12
   \   000024   ........     CALLA   #HalLcdWriteString
   1090          
   1091            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
   1092                                                    PULSE_DAT_LEN, pulseDat, &pulseTSN, AF_DISCV_ROUTE,AF_DEFAULT_RADIUS))
   \   000028   70121E00     PUSH.B  #0x1e
   \   00002C   70122000     PUSH.B  #0x20
   \   000030   3012....     PUSH.W  #pulseTSN
   \   000034   3012....     PUSH.W  #pulseDat
   \   000038   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_25:
   \   00003C   3152         ADD.W   #0x8, SP
   \   00003E   4C93         CMP.B   #0x0, R12
   \   000040   0524         JEQ     ??pulseNodeCheckIn_0
   1093              { //if data transfer is unsuccessful place event immediately back into queue to attempt to send again
   1094                  osal_set_event(pulseTaskId, PULSE_EVT_CHECKIN);
   \   000042   ........     CALLA   #?Subroutine5
   1095            }
   \                     ??CrossCallReturnLabel_17:
   \   000046   ........     CALLA   #osal_set_event
   \   00004A   023C         JMP     ??pulseNodeCheckIn_1
   1096            else
   1097            {
   1098              pulseCnt++;
   \                     ??pulseNodeCheckIn_0:
   \   00004C   9253....     ADD.W   #0x1, &pulseCnt
   1099            }
   1100            if((QS == FALSE) && (Flag == FALSE)){
   \                     ??pulseNodeCheckIn_1:
   \   000050   C293....     CMP.B   #0x0, &QS
   \   000054   0B20         JNE     ??pulseNodeCheckIn_2
   \   000056   C293....     CMP.B   #0x0, &??Flag
   \   00005A   0820         JNE     ??pulseNodeCheckIn_2
   1101              osal_start_timerEx(pulseTaskId, PULSE_EVT_CHECKIN, PULSE_DLY_CHECKIN);  //send check in dummy packet every 10 seconds
   \   00005C   3E401027     MOV.W   #0x2710, R14
   \   000060   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_18:
   \   000064   ........     CALLA   #osal_start_timerEx
   1102              Flag = TRUE;  //to prevent restarting of timer if existing already running
   \   000068   D243....     MOV.B   #0x1, &??Flag
   1103               
   1104            }
   1105            
   1106          }
   \                     ??pulseNodeCheckIn_2:
   \   00006C                REQUIRE ?Subroutine1
   \   00006C                // Fall through to label ?Subroutine1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??Flag:
   \   000000                DS8 1
   1107          
   1108          /**************************************************************************************************
   1109           * @fn          TestPayloadTx
   1110           *
   1111           * @brief       This function is called by the pulseAppEvt() function. This function is used to test 
   1112           *              network loading by sending test payloads that have a packet size and Tx frequency that
   1113           *              are user defined.  This is operated on a timer and is initiated by SW1.
   1114           * input parameters
   1115           *
   1116           *
   1117           * output parameters
   1118           *
   1119           * None.
   1120           *
   1121           * @return      None.
   1122           **************************************************************************************************
   1123           */

   \                                 In  segment CODE, align 2
   1124          static void TestPayloadTx(void){
   \                     TestPayloadTx:
   \   000000   0A12         PUSH.W  R10
   \   000002   31800C00     SUB.W   #0xc, SP
   1125            static uint8 SeqNum =0;
   1126            static bool flag = FALSE;
   1127            afAddrType_t addr;                    //AF address stucture defined for info on the destination Endpoint object that data will be sent to
   1128            
   1129            // Turn off collecting data and regular Pulse report generation for Payload testing
   1130            osal_stop_timerEx(pulseTaskId, PULSE_EVT_CHECKIN);
   \   000006   3A40....     MOV.W   #pulseTaskId, R10
   \   00000A   3D400008     MOV.W   #0x800, R13
   \   00000E   6C4A         MOV.B   @R10, R12
   \   000010   ........     CALLA   #osal_stop_timerEx
   1131            osal_stop_timerEx(pulseTaskId, PULSE_EVT_DAT);
   \   000014   3D400010     MOV.W   #0x1000, R13
   \   000018   6C4A         MOV.B   @R10, R12
   \   00001A   ........     CALLA   #osal_stop_timerEx
   1132            osal_stop_timerEx(pulseTaskId, PULSE_EVT_REQ);
   \   00001E   3D400020     MOV.W   #0x2000, R13
   \   000022   6C4A         MOV.B   @R10, R12
   \   000024   ........     CALLA   #osal_stop_timerEx
   1133            
   1134            TestDatTx[11] = SeqNum;
   \   000028   D242........ MOV.B   &??SeqNum, &TestDatTx + 11
   1135            TestDatTx[PULSE_CMD_IDX] = PULSE_CMD_DAT_TEST;
   \   00002E   F2400300.... MOV.B   #0x3, &TestDatTx
   1136            if( flag == FALSE){
   \   000034   C293....     CMP.B   #0x0, &??flag
   \   000038   0220         JNE     ??TestPayloadTx_0
   1137            SeqNum++;
   \   00003A   D253....     ADD.B   #0x1, &??SeqNum
   1138            }
   1139            flag = FALSE;
   \                     ??TestPayloadTx_0:
   \   00003E   C243....     MOV.B   #0x0, &??flag
   1140            addr.addr.shortAddr = pulseAddr;      //loading short address (16-bit) with pulse address
   \   000042   ........     CALLA   #?Subroutine2
   1141            addr.addrMode = afAddr16Bit;          //Set to directly sent to a node
   1142            addr.endPoint = PULSE_ENDPOINT;       //Sets the endpoint of the final destination (coordinator?)
   1143          
   1144            
   1145            HalLcdWriteString("TestPayload TX",HAL_LCD_LINE_5);
   \                     ??CrossCallReturnLabel_0:
   \   000046   7D400500     MOV.B   #0x5, R13
   \   00004A   3C40....     MOV.W   #`?<Constant "TestPayload TX">`, R12
   \   00004E   ........     CALLA   #HalLcdWriteString
   1146          
   1147            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
   1148                                                    MHMS_TEST_PAYLOAD_LEN, TestDatTx, &pulseTSN, AF_DISCV_ROUTE,AF_DEFAULT_RADIUS))
   \   000052   70121E00     PUSH.B  #0x1e
   \   000056   70122000     PUSH.B  #0x20
   \   00005A   3012....     PUSH.W  #pulseTSN
   \   00005E   3012....     PUSH.W  #TestDatTx
   \   000062   3F403200     MOV.W   #0x32, R15
   \   000066   ........     CALLA   #??Subroutine14_0
   \                     ??CrossCallReturnLabel_23:
   \   00006A   3152         ADD.W   #0x8, SP
   \   00006C   4C93         CMP.B   #0x0, R12
   \   00006E   0624         JEQ     ??TestPayloadTx_1
   1149              { //if data transfer is unsuccessful place event immediately back into queue to attempt to send again
   1150                  osal_set_event(pulseTaskId, TEST_EVT_PAYLOAD_TX);
   \   000070   3D400004     MOV.W   #0x400, R13
   \   000074   ........     CALLA   #?Subroutine6
   1151                  flag = TRUE;
   \                     ??CrossCallReturnLabel_9:
   \   000078   D243....     MOV.B   #0x1, &??flag
   1152            }
   1153               osal_start_timerEx(pulseTaskId, TEST_EVT_PAYLOAD_TX, TEST_DLY_PAYLOAD_TX);  //send check in dummy packet every 10 seconds
   \                     ??TestPayloadTx_1:
   \   00007C   3E401027     MOV.W   #0x2710, R14
   \   000080   3D400004     MOV.W   #0x400, R13
   \   000084   6C4A         MOV.B   @R10, R12
   \   000086   ........     CALLA   #osal_start_timerEx
   1154            
   1155          }
   \   00008A   31500C00     ADD.W   #0xc, SP
   \   00008E   3A41         POP.W   R10
   \   000090   1001         RETA

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??SeqNum:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??flag:
   \   000000                DS8 1
   1156          
   1157          //MHMS Question do we need this ? tvsaUartRx  this is for recieving command messages from UART
   1158          /**************************************************************************************************
   1159           * @fn          pulseUartRx
   1160           *
   1161           * @brief       This function is the Uart callback for Rx data.
   1162           *
   1163           * input parameters
   1164           *
   1165           * @param       port - Don't care.
   1166           * @param       event - Don't care.
   1167           *
   1168           * output parameters
   1169           *
   1170           * None.
   1171           *
   1172           * @return      None.
   1173           **************************************************************************************************
   1174           */
   1175          

   \                                 In  segment CODE, align 2
   1176          static void pulseUartRx(uint8 port, uint8 event)
   \                     pulseUartRx:
   1177          {
   \   000000   31800600     SUB.W   #0x6, SP
   1178          #ifdef TVSA_DEMO
   1179            uint8 ch;
   1180          
   1181            while (HalUARTRead(PULSE_PORT, &ch, 1))
   1182            {
   1183              switch (pulseState)
   1184              {
   1185              case SOP_STATE:
   1186                if (PULSE_SOP_VAL == ch)
   1187                {
   1188                  pulseState = CMD_STATE;
   1189                }
   1190                break;
   1191          
   1192              case CMD_STATE:
   1193                pulseCmd = ch;
   1194                pulseState = FCS_STATE;
   1195                break;
   1196          
   1197              case FCS_STATE:
   1198                if (pulseCmd == ch)
   1199                {
   1200                  if (pulseCmd == PULSE_CMD_BEG)
   1201                  {
   1202                    pulseAddr = NLME_GetShortAddr();
   1203                  }
   1204                  else if (pulseCmd == PULSE_CMD_END)
   1205                  {
   1206                    pulseAddr = INVALID_NODE_ADDR;
   1207                  }
   1208                  (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   1209                }
   1210          
   1211                pulseState = SOP_STATE;
   1212                break;
   1213          
   1214              default:
   1215               break;
   1216              }
   1217            }
   1218          #else
   1219            uint8 ch[5];
   1220            
   1221            HalUARTRead(PULSE_PORT, ch, 5);
   \   000004   3E400500     MOV.W   #0x5, R14
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   \   00000C   4C43         MOV.B   #0x0, R12
   \   00000E   ........     CALLA   #HalUARTRead
   1222            if (ch[2]==0x21)   //if statement to check for command from Z-Sensor Monitor
   \   000012   F19021000200 CMP.B   #0x21, 0x2(SP)
   \   000018   0220         JNE     ??pulseUartRx_0
   1223            {
   1224              sysPingRsp();
   \   00001A   ........     CALLA   #sysPingRsp
   1225            }
   1226          #endif
   1227          }
   \                     ??pulseUartRx_0:
   \   00001E   31500600     ADD.W   #0x6, SP
   \   000022   1001         RETA
   1228          
   1229          #ifndef TVSA_DEMO
   1230          /******************************************************************************
   1231           * @fn          calcFCS
   1232           *
   1233           * @brief       This function calculates the FCS checksum for the serial message 
   1234           *
   1235           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
   1236           *              len - Length of the pBuf.
   1237           *
   1238           * @return      The calculated FCS.
   1239           ******************************************************************************
   1240           */

   \                                 In  segment CODE, align 2
   1241          static uint8 calcFCS(uint8 *pBuf, uint8 len)
   \                     calcFCS:
   1242          {
   1243            uint8 rtrn = 0;
   \   000000   4F43         MOV.B   #0x0, R15
   \   000002   013C         JMP     ??calcFCS_1
   1244          
   1245            while (len--)
   1246            {
   1247              rtrn ^= *pBuf++;
   \                     ??calcFCS_0:
   \   000004   7FEC         XOR.B   @R12+, R15
   1248            }
   \                     ??calcFCS_1:
   \   000006   4E4D         MOV.B   R13, R14
   \   000008   7D53         ADD.B   #0xff, R13
   \   00000A   4E93         CMP.B   #0x0, R14
   \   00000C   FB23         JNE     ??calcFCS_0
   1249          
   1250            return rtrn;
   \   00000E   4C4F         MOV.B   R15, R12
   \   000010   1001         RETA
   1251          }
   1252          
   1253          /*************************************************************************************************
   1254           * @fn          sysPingRsp
   1255           *
   1256           * @brief       Build and send Ping response
   1257           *
   1258           * @param       none
   1259           *              
   1260           * @return      none
   1261          **************************************************************************************************
   1262           */

   \                                 In  segment CODE, align 2
   1263          static void sysPingRsp(void)
   \                     sysPingRsp:
   1264          {
   \   000000   3182         SUB.W   #0x8, SP
   1265            uint8 pingBuff[7];
   1266            
   1267            // Start of Frame Delimiter
   1268            pingBuff[0] = 0xFE;
   \   000002   F140FE000000 MOV.B   #0xfe, 0(SP)
   1269            
   1270            // Length
   1271            pingBuff[1] = 0x02; 
   \   000008   E1430100     MOV.B   #0x2, 0x1(SP)
   1272            
   1273            // Command type
   1274            pingBuff[2] = LO_UINT16(0x0161); 
   \   00000C   F14061000200 MOV.B   #0x61, 0x2(SP)
   1275            pingBuff[3] = HI_UINT16(0x0161);
   \   000012   D1430300     MOV.B   #0x1, 0x3(SP)
   1276            
   1277            // Stack profile
   1278            pingBuff[4] = LO_UINT16(0x0041);
   \   000016   F14041000400 MOV.B   #0x41, 0x4(SP)
   1279            pingBuff[5] = HI_UINT16(0x0041);
   \   00001C   C1430500     MOV.B   #0x0, 0x5(SP)
   1280            
   1281            // Frame Check Sequence
   1282            pingBuff[6] = calcFCS(&pingBuff[1], 5);
   \   000020   7D400500     MOV.B   #0x5, R13
   \   000024   0C41         MOV.W   SP, R12
   \   000026   1C53         ADD.W   #0x1, R12
   \   000028   ........     CALLA   #calcFCS
   \   00002C   C14C0600     MOV.B   R12, 0x6(SP)
   1283            
   1284            
   1285            HalUARTWrite(PULSE_PORT,pingBuff, 7);
   \   000030   3E400700     MOV.W   #0x7, R14
   \   000034   ........     CALLA   #?Subroutine4
   1286          
   1287          }
   \                     ??CrossCallReturnLabel_6:
   \   000038   3152         ADD.W   #0x8, SP
   \   00003A   1001         RETA

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for IBI>`:
   \   000000   5802         DC16 600

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for P>`:
   \   000000   0002         DC16 512

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for T>`:
   \   000000   0002         DC16 512

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for thresh>`:
   \   000000   0002         DC16 512

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for amp>`:
   \   000000   6400         DC16 100

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for firstBeat>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for secondBeat>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BPM:">`:
   \   000000   42504D3A00   DC8 "BPM:"

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BPMsensor Inacti">`:
   \   000000   42504D73656E DC8 "BPMsensor Inacti"
   \            736F7220496E
   \            6163746900  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "TestPayload TX">`:
   \   000000   546573745061 DC8 "TestPayload TX"
   \            796C6F616420
   \            545800      
   1288          #endif
   1289          /**************************************************************************************************
   1290          */
   1291          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      26  TestPayloadTx
            26 -> AF_DataRequest
            18 -> HalLcdWriteString
            18 -> osal_set_event
            18 -> osal_start_timerEx
            18 -> osal_stop_timerEx
       4  calcFCS
       6  pulseAfMsgRx
             6 -> NLME_SetPollRate
             6 -> osal_set_event
             6 -> pulseDataRx
             6 -> pulseTestingDataRx
      28  pulseAnnce
            28 -> AF_DataRequest
            20 -> osal_set_event
            20 -> osal_start_timerEx
      12  pulseAppEvt
            12 -> TestPayloadTx
            12 -> osal_msg_deallocate
            12 -> osal_msg_receive
            12 -> pulseAfMsgRx
            12 -> pulseAnnce
            12 -> pulseDataCalc
            12 -> pulseDataReq
            12 -> pulseNodeCheckIn
            12 -> pulseZdoStateChange
      40  pulseAppInit
            40 -> HalUARTOpen
            40 -> afRegister
      24  pulseBPM
            20 -> HalAdcRead
            20 -> HalLcdWriteStringValue
            20 -> HalLedSet
       6  pulseDataCalc
             6 -> osal_set_event
             6 -> osal_start_timerEx
             6 -> pulseBPM
      24  pulseDataReq
            24 -> AF_DataRequest
            16 -> osal_set_event
            16 -> osal_start_timerEx
            16 -> osal_stop_timerEx
      28  pulseDataRx
            28 -> HalUARTWrite
            28 -> calcFCS
            28 -> osal_memcpy
            28 -> osal_set_event
      24  pulseNodeCheckIn
            24 -> AF_DataRequest
            16 -> HalLcdWriteString
            16 -> osal_set_event
            16 -> osal_start_timerEx
            16 -> osal_stop_timerEx
      28  pulseTestingDataRx
            28 -> HalUARTWrite
            28 -> calcFCS
            28 -> osal_memcpy
            28 -> osal_set_event
      10  pulseUartRx
            10 -> HalUARTRead
            10 -> sysPingRsp
      12  pulseZdoStateChange
            12 -> HalLcdWriteValue
            12 -> NLME_GetCoordShortAddr
            12 -> Onboard_rand
            12 -> osal_set_event
            12 -> osal_start_timerEx
            12 -> osal_stop_timerEx
            12 -> sAddrExtCpy
      12  sysPingRsp
            12 -> HalUARTWrite
            12 -> calcFCS


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "BPM:">
      17  ?<Constant "BPMsensor Inacti">
      15  ?<Constant "TestPayload TX">
       2  ?<Initializer for IBI>
       2  ?<Initializer for P>
       2  ?<Initializer for T>
       2  ?<Initializer for amp>
       1  ?<Initializer for firstBeat>
       1  ?<Initializer for secondBeat>
       2  ?<Initializer for thresh>
       8  ??Subroutine14_0
       8  ??Subroutine15_0
      98  ?Subroutine0
       6  ?Subroutine1
      22  ?Subroutine10
       8  ?Subroutine11
      14  ?Subroutine12
       6  ?Subroutine13
      18  ?Subroutine2
      26  ?Subroutine3
      10  ?Subroutine4
       8  ?Subroutine5
       6  ?Subroutine6
       4  ?Subroutine7
       4  ?Subroutine8
       4  ?Subroutine9
       2  BPM
       1  Flag
       2  IBI
       2  P
       2  PULSE_ClusterList
      14  PULSE_SimpleDesc
       8  PULSE_epDesc
       1  Pulse
       1  PulseEvtCheckin_sync
       1  PulseEvtDat_sync
       1  PulseEvtReq_sync
       1  QS
       1  SeqNum
       2  Signal
       2  T
      50  TestDatTx
     146  TestPayloadTx
      53  TestRxBuffer
       2  _A_PCDIR_L
       2  _A_PCOUT_L
       2  _A_REFCTL0_L
       2  amp
      18  calcFCS
       1  firstBeat
       1  flag
       4  lastBeatTime
       2  pulseAddr
     102  pulseAfMsgRx
     124  pulseAnnce
     148  pulseAppEvt
     130  pulseAppInit
     436  pulseBPM
      25  pulseBuf
       2  pulseCnt
      22  pulseDat
      96  pulseDataCalc
     100  pulseDataReq
       1  pulseDataReqFlag
      96  pulseDataRx
     108  pulseNodeCheckIn
       1  pulseTSN
       1  pulseTaskId
      80  pulseTestingDataRx
      36  pulseUartRx
     286  pulseZdoStateChange
      20  rate
       4  sampleCounter
       1  secondBeat
      60  sysPingRsp
       2  thresh

 
 2 216 bytes in segment CODE
     6 bytes in segment DATA16_AN
    61 bytes in segment DATA16_C
    12 bytes in segment DATA16_I
    12 bytes in segment DATA16_ID
   197 bytes in segment DATA16_Z
 
 2 216 bytes of CODE  memory
    73 bytes of CONST memory
   209 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: 4
