###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       26/Apr/2013  15:12:58 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\Source\zap_app.c                   #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1             #
#                     -DHAL_UART=1 -DZAP_PHY_SPI=1                            #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\Source\zap_app.c -lC               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\ -lA  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\      #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\       #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\zap_a #
#                     pp.lst                                                  #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\zap_ap #
#                     p.r43                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\Source\zap_app.c
      1          /**************************************************************************************************
      2              Filename:       zap_app.c
      3              Revised:        $Date: 2011-07-05 11:35:58 -0700 (Tue, 05 Jul 2011) $
      4              Revision:       $Revision: 26589 $
      5          
      6              Description:
      7          
      8              This file defines the functionality of the ZNP Application Processor.
      9          
     10          
     11              Copyright 2009-2011 Texas Instruments Incorporated. All rights reserved.
     12          
     13              IMPORTANT: Your use of this Software is limited to those specific rights
     14              granted under the terms of a software license agreement between the user
     15              who downloaded the software, his/her employer (which must be your employer)
     16              and Texas Instruments Incorporated (the "License").  You may not use this
     17              Software unless you agree to abide by the terms of the License. The License
     18              limits your use, and you acknowledge, that the Software may not be modified,
     19              copied or distributed unless embedded on a Texas Instruments microcontroller
     20              or used solely and exclusively in conjunction with a Texas Instruments radio
     21              frequency transceiver, which is integrated into your product.  Other than for
     22              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23              works of, modify, distribute, perform, display or sell this Software and/or
     24              its documentation for any purpose.
     25          
     26              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38              Should you have any questions regarding your right to use this Software,
     39              contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "hal_board.h"

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x120
   \   union <unnamed> _A_PMMCTL0_L
   \                     _A_PMMCTL0_L:
   \   000000                DS8 2
     48          #include "hal_key.h"
     49          #include "hal_lcd.h"
     50          #include "hal_led.h"
     51          #include "mt.h"
     52          #include "mt_rpc.h"
     53          #include "mt_sys.h"
     54          #include "mt_uart.h"
     55          #include "OSAL.h"
     56          #include "OSAL_Tasks.h"
     57          //MHMS: Inlude NV memory read and write stuff
     58          #include "OSAL_Nv.h"
     59          #include "sapi.h"
     60          #include "zap_app.h"
     61          #include "zap_phy.h"
     62          #include "zap_znp.h"
     63          #include "ZDApp.h"
     64          #include "ZDObject.h"
     65          #include "ZComDef.h"
     66             
     67          #include "tvsa.h"          
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                           Constants
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          
     74          #if !defined ZAP_APP_PORT
     75          #define ZAP_APP_PORT  0
     76          #endif
     77          
     78          #if !defined ZAP_APP_LED
     79          #define ZAP_APP_LED   FALSE
     80          #endif
     81          
     82          #if !defined ZAP_APP_KEYS
     83          #define ZAP_APP_KEYS  TRUE
     84          #endif
     85          
     86          /* ------------------------------------------------------------------------------------------------
     87           *                                           Typedefs
     88           * ------------------------------------------------------------------------------------------------
     89           */
     90          
     91          typedef void (*zapProcessFunc_t)(uint8 port, uint8 *pBuf);
     92          
     93          /* ------------------------------------------------------------------------------------------------
     94           *                                           Macros
     95           * ------------------------------------------------------------------------------------------------
     96           */
     97          
     98          /* ------------------------------------------------------------------------------------------------
     99           *                                           Global Variables
    100           * ------------------------------------------------------------------------------------------------
    101           */
    102          //MHMS:Switches Logical type

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    103          static uint8 zLogicalType=ZG_DEVICETYPE_ROUTER;
   \                     zLogicalType:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for zLogicalType>`
    104          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    105          uint8 zapTaskId;
   \                     zapTaskId:
   \   000000                DS8 1
    106          
    107          // Hook for supporting more than 1 ZNP on different ports.
    108          // An example of use would be to set this to the desired port before invoking AF_DataRequest().

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    109          uint8 zapAppPort;
   \                     zapAppPort:
   \   000000                DS8 1
    110          
    111          // Count of the global ZNP variables that are cached locally on ZAP.
    112          #define ZAP_MON_INFO_CNT  5
    113          
    114          //MHMS:Sending the IEEE address will
    115          // IEEE Address (64-bit Extended Address) of the ZNP device.

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    116          uint8 znpIEEE[8];
   \                     znpIEEE:
   \   000000                DS8 8
    117          
    118          // ZigBee Network Address of the ZNP device.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    119          uint16 znpAddr;
   \                     znpAddr:
   \   000000                DS8 2
    120          // ZigBee Network Address of the parent of the ZNP device.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    121          uint16 znpParent;
   \                     znpParent:
   \   000000                DS8 2
    122          // ZigBee Network PanId.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    123          uint16 znpPanId;
   \                     znpPanId:
   \   000000                DS8 2
    124          // ZNP variable indicating the current device state (from Z-Stack ZDO/ZD_App.c).

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    125          devStates_t devState;
   \                     devState:
   \   000000                DS8 1
    126          
    127          #if SECURE
    128          // ZNP variable read from NV at powerup by the ZGlobals manager - TODO: how to sync value with ZNP?
    129          uint8 zgSecurityMode = ZG_SECURITY_MODE;
    130          #endif
    131          
    132          // Trust center address

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    133          uint16 zgTrustCenterAddr = ZG_TRUSTCENTER_ADDR;
   \                     zgTrustCenterAddr:
   \   000000                DS8 2
    134          
    135          /* ------------------------------------------------------------------------------------------------
    136           *                                           Local Variables
    137           * ------------------------------------------------------------------------------------------------
    138           */
    139          

   \                                 In  segment DATA16_C, align 2, align-sorted
    140          static const zapProcessFunc_t zapProcessFunc[] =
   \                     zapProcessFunc:
   \   000000   00000000.... DC32 0H, zapSysProcessIncoming, 0H, 0H, zapAfProcessIncoming
   \            ....00000000
   \            00000000....
   \            ....        
   \   000014   ............ DC32 zapZdoProcessIncoming, zapSapiProcessIncoming
   \            ....        
   \   00001C   ........0000 DC32 zapUtilProcessIncoming, 0H, 0H
   \            000000000000
    141          {
    142            NULL,
    143          
    144          #if defined (ZAP_SYS_FUNC)
    145            zapSysProcessIncoming,
    146          #else
    147            NULL,
    148          #endif
    149          
    150          #if defined (ZAP_MAC_FUNC)
    151            zapMacProcessIncoming,
    152          #else
    153            NULL,
    154          #endif
    155          
    156          #if defined (ZAP_NWK_FUNC)
    157            zapNwkProcessIncoming,
    158          #else
    159            NULL,
    160          #endif
    161          
    162          #if defined (ZAP_AF_FUNC)
    163            zapAfProcessIncoming,
    164          #else
    165            NULL,
    166          #endif
    167          
    168          #if defined (ZAP_ZDO_FUNC)
    169            zapZdoProcessIncoming,
    170          #else
    171            NULL,
    172          #endif
    173          
    174          #if defined (ZAP_SAPI_FUNC)
    175            zapSapiProcessIncoming,
    176          #else
    177            NULL,
    178          #endif
    179          
    180          #if defined (ZAP_UTIL_FUNC)
    181            zapUtilProcessIncoming,
    182          #else
    183            NULL,
    184          #endif
    185          
    186          #if defined (ZAP_DEBUG_FUNC)
    187            zapDebugProcessIncoming,
    188          #else
    189            NULL,
    190          #endif
    191          
    192          #if defined (ZAP_APP_FUNC)
    193            zapApsProcessIncoming,
    194          #else
    195            NULL,
    196          #endif
    197          };
    198          
    199          #ifdef LCD_SUPPORTED

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    200          static uint16 zapDisAddr;
   \                     zapDisAddr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    201          static uint16 zapDisPanId;
   \                     zapDisPanId:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    202          static uint8  zapDisIEEE[Z_EXTADDR_LEN];
   \                     zapDisIEEE:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    203          static uint8  zapDisState;
   \                     zapDisState:
   \   000000                DS8 1
    204          #endif
    205          
    206          /* ------------------------------------------------------------------------------------------------
    207           *                                           Local Functions
    208           * ------------------------------------------------------------------------------------------------
    209           */
    210          
    211          #if ZAP_ZNP_MT
    212          #include "zap_phy_uart.c"
    213          #if ZAP_APP_MSG
    214          #define MT_APP_FUNC
    215          #include "MT_App.c"
    216          #endif
    217          #endif
    218          
    219          #ifdef LCD_SUPPORTED
    220          static void zapDisInfo(void);
    221          #endif
    222          static void zapMonInfo(void);
    223          #if ZAP_APP_KEYS
    224          static void zapKeys(keyChange_t *msg);
    225          #endif
    226          static void zapMonitor(void);
    227          static void zapSync(void);
    228          static void zapSysEvtMsg(void);
    229          
    230          //MHMS:Adding function from ZGlobals.c to avoid includes
    231          uint8 zgWriteStartupOptions( uint8 action, uint8 bitOptions );
    232          
    233          /*********************************************************************
    234           * @fn          zgWriteStartupOptions
    235           *
    236           * @brief       Writes bits into the ZCD_NV_STARTUP_OPTION NV Item.
    237           *
    238           * @param       action - ZG_STARTUP_SET set bit, ZG_STARTUP_CLEAR to
    239           *               clear bit. The set bit is an OR operation, and the
    240           *               clear bit is an AND ~(bitOptions) operation.
    241           *
    242           * @param       bitOptions - which bits to perform action on:
    243           *                      ZCD_STARTOPT_DEFAULT_CONFIG_STATE
    244           *                      ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    245             
    246           *
    247           * @return      ZSUCCESS if successful
    248           */

   \                                 In  segment CODE, align 2
    249          uint8 zgWriteStartupOptions( uint8 action, uint8 bitOptions )
   \                     zgWriteStartupOptions:
    250          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4B4C         MOV.B   R12, R11
   \   000006   4A4D         MOV.B   R13, R10
    251            uint8 status;
    252            uint8 startupOptions = 0;
   \   000008   C1430000     MOV.B   #0x0, 0(SP)
    253          
    254            status = osal_nv_read( ZCD_NV_STARTUP_OPTION,
    255                          0,
    256                          sizeof( startupOptions ),
    257                          &startupOptions );
   \   00000C   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_10:
   \   000010   ........     CALLA   #osal_nv_read
    258          
    259            if ( status == ZSUCCESS )
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   0C20         JNE     ??zgWriteStartupOptions_0
    260            {
    261              if ( action == ZG_STARTUP_SET )
   \   000018   7B93         CMP.B   #0xff, R11
   \   00001A   0220         JNE     ??zgWriteStartupOptions_1
    262              {
    263                // Set bits
    264                startupOptions |= bitOptions;
   \   00001C   6AD1         BIS.B   @SP, R10
   \   00001E   023C         JMP     ??zgWriteStartupOptions_2
    265              }
    266              else
    267              {
    268                // Clear bits
    269                startupOptions &= (bitOptions ^ 0xFF);
   \                     ??zgWriteStartupOptions_1:
   \   000020   7AE3         XOR.B   #0xff, R10
   \   000022   6AF1         AND.B   @SP, R10
   \                     ??zgWriteStartupOptions_2:
   \   000024   C14A0000     MOV.B   R10, 0(SP)
    270              }
    271          
    272              // Changed?
    273              status = osal_nv_write( ZCD_NV_STARTUP_OPTION,
    274                           0,
    275                           sizeof( startupOptions ),
    276                           &startupOptions );
   \   000028   ........     CALLA   #?Subroutine7
    277            }
   \                     ??CrossCallReturnLabel_11:
   \   00002C   ........     CALLA   #osal_nv_write
    278          
    279            return ( status );
   \                     ??zgWriteStartupOptions_0:
   \   000030   2153         ADD.W   #0x2, SP
   \   000032   1A17         POPM.W  #0x2, R11
   \   000034   1001         RETA
    280          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine7:
   \   000000   0F41         MOV.W   SP, R15
   \   000002   2F52         ADD.W   #0x4, R15
   \   000004   1E43         MOV.W   #0x1, R14
   \   000006   0D43         MOV.W   #0x0, R13
   \   000008   3C400300     MOV.W   #0x3, R12
   \   00000C   1001         RETA
    281          /**************************************************************************************************
    282           * @fn          zapInit
    283           *
    284           * @brief       This function is the application's task initialization.
    285           *
    286           * input parameters
    287           *
    288           * None.
    289           *
    290           * output parameters
    291           *
    292           * None.
    293           *
    294           * @return      None.
    295           **************************************************************************************************
    296           */

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   3E40E803     MOV.W   #0x3e8, R14
   \   000004   3D400010     MOV.W   #0x1000, R13
   \   000008   5C42....     MOV.B   &zapTaskId, R12
   \   00000C   ........     CALLA   #osal_start_timerEx
   \   000010   4C93         CMP.B   #0x0, R12
   \   000012   0624         JEQ     ??zapMonitor_0
   \   000014   3D400010     MOV.W   #0x1000, R13
   \   000018   5C42....     MOV.B   &zapTaskId, R12
   \   00001C   ........     CALLA   #osal_set_event
   \                     ??zapMonitor_0:
   \   000020   1001         RETA

   \                                 In  segment CODE, align 2
    297          void zapInit(uint8 id)
   \                     zapInit:
    298          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    299            zapTaskId = id;
   \   000004   C24C....     MOV.B   R12, &zapTaskId
    300            zapAppPort = ZAP_APP_PORT;
   \   000008   C243....     MOV.B   #0x0, &zapAppPort
    301          
    302            zapPhyInit();
   \   00000C   ........     CALLA   #zapPhyInit
    303          #if ZAP_APP_KEYS
    304            RegisterForKeys(id);
   \   000010   4C4A         MOV.B   R10, R12
   \   000012   ........     CALLA   #RegisterForKeys
    305          #endif
    306          
    307            zapLostSync(ZAP_APP_PORT);
   \   000016   4C43         MOV.B   #0x0, R12
   \   000018   ........     CALLA   #zapLostSync
    308            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_TMR_EVT, ZAP_APP_TMR_DLY))
   \   00001C   ........     CALLA   #?Subroutine1
    309            {
    310              (void)osal_set_event(zapTaskId, ZAP_APP_TMR_EVT);
    311            }
    312          
    313          #if !ZAP_PHY_RESET_ZNP
    314            uint8 *pBuf;
    315            if ((pBuf = zap_msg_allocate(0, (uint8)MT_RPC_SYS_UTIL | (uint8)MT_RPC_CMD_AREQ,
    316                                            (uint8)MT_UTIL_SYNC_REQ)) != NULL)
    317            {
    318              zapPhySend(zapAppPort, pBuf);
    319              zap_msg_deallocate(&pBuf);
    320            }
    321          #endif
    322          
    323          #if ZAP_ZNP_MT
    324            zapPhyUartInit();
    325          #endif
    326          }
   \                     ??CrossCallReturnLabel_0:
   \   000020   3A41         POP.W   R10
   \   000022   1001         RETA
    327          
    328          /**************************************************************************************************
    329           * @fn          zapEvt
    330           *
    331           * @brief       This function is called to process the OSAL events for the task.
    332           *
    333           * input parameters
    334           *
    335           * @param       id - OSAL task Id.
    336           * @param       evts - OSAL events bit mask of pending events.
    337           *
    338           * output parameters
    339           *
    340           * None.
    341           *
    342           * @return      evts - OSAL events bit mask of unprocessed events.
    343           **************************************************************************************************
    344           */

   \                                 In  segment CODE, align 2
    345          uint16 zapEvt(uint8 id, uint16 evts)
   \                     zapEvt:
    346          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4D         MOV.W   R13, R10
    347            uint16 mask = 0;
    348            (void)id;
    349          
    350            if (evts & SYS_EVENT_MSG)
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1C34         JGE     ??zapEvt_4
    351            {
    352              mask = SYS_EVENT_MSG;
   \   000008   3B400080     MOV.W   #0x8000, R11
    353              zapSysEvtMsg();
   \   00000C   093C         JMP     ??zapEvt_5
   \                     ??zapEvt_0:
   \   00000E   1D4C0200     MOV.W   0x2(R12), R13
   \   000012   5C480100     MOV.B   0x1(R8), R12
   \   000016   ........     CALLA   #zapProcessIncoming
   \                     ??zapEvt_1:
   \   00001A   0C48         MOV.W   R8, R12
   \   00001C   ........     CALLA   #osal_msg_deallocate
   \                     ??zapEvt_5:
   \   000020   5C42....     MOV.B   &zapTaskId, R12
   \   000024   ........     CALLA   #osal_msg_receive
   \   000028   084C         MOV.W   R12, R8
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   3224         JEQ     ??zapEvt_6
   \   00002E   6E4C         MOV.B   @R12, R14
   \   000030   5E83         SUB.B   #0x1, R14
   \   000032   ED27         JEQ     ??zapEvt_0
   \   000034   7E80BF00     SUB.B   #0xbf, R14
   \   000038   F023         JNE     ??zapEvt_1
   \   00003A   ........     CALLA   #zapKeys
   \   00003E   ED3F         JMP     ??zapEvt_1
    354            }
    355            else if (evts & (ZAP_PHY_SPI_EVT | ZAP_PHY_UART_EVT))
   \                     ??zapEvt_4:
   \   000040   0B4D         MOV.W   R13, R11
   \   000042   3BF00060     AND.W   #0x6000, R11
   \   000046   0424         JEQ     ??zapEvt_7
    356            {
    357              mask = evts & (ZAP_PHY_SPI_EVT | ZAP_PHY_UART_EVT);
    358              zapPhyExec(mask);
   \   000048   0C4B         MOV.W   R11, R12
   \   00004A   ........     CALLA   #zapPhyExec
   \   00004E   213C         JMP     ??zapEvt_6
    359            }
    360            else if (evts & ZAP_APP_TMR_EVT)
   \                     ??zapEvt_7:
   \   000050   3DB00010     BIT.W   #0x1000, R13
   \   000054   0528         JNC     ??zapEvt_8
    361            {
    362              mask = ZAP_APP_TMR_EVT;
   \   000056   3B400010     MOV.W   #0x1000, R11
    363              zapMonitor();
   \   00005A   ........     CALLA   #zapMonitor
   \   00005E   193C         JMP     ??zapEvt_6
    364            }
    365            else if (evts & ZAP_APP_SYNC_EVT)
   \                     ??zapEvt_8:
   \   000060   3DB00008     BIT.W   #0x800, R13
   \   000064   0528         JNC     ??zapEvt_9
    366            {
    367              mask = ZAP_APP_SYNC_EVT;
   \   000066   3B400008     MOV.W   #0x800, R11
    368              zapSync();
   \   00006A   ........     CALLA   #zapSync
   \   00006E   113C         JMP     ??zapEvt_6
    369            }
    370            else if (evts & ZAP_APP_ZDO_STATE_CHANGE_EVT)
   \                     ??zapEvt_9:
   \   000070   3DB00004     BIT.W   #0x400, R13
   \   000074   0D28         JNC     ??zapEvt_10
    371            {
    372              mask = ZAP_APP_ZDO_STATE_CHANGE_EVT;
   \   000076   3B400004     MOV.W   #0x400, R11
    373          
    374          #ifdef LCD_SUPPORTED
    375              // Loop to get all of the cached, global ZNP variables for the sake of a timely LCD update.
    376              for (id = 0; id <= ZAP_MON_INFO_CNT; id++)
   \   00007A   78400600     MOV.B   #0x6, R8
    377              {
    378                zapMonInfo();
   \                     ??zapEvt_2:
   \   00007E   ........     CALLA   #zapMonInfo
    379              }
   \   000082   7853         ADD.B   #0xff, R8
   \   000084   FC23         JNE     ??zapEvt_2
    380          #else
    381              // Otherwise, just get what is needed for the ZDO state change update.
    382              zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
    383          #endif
    384          
    385              ZDO_UpdateNwkStatus(devState);
   \   000086   5C42....     MOV.B   &devState, R12
   \   00008A   ........     CALLA   #ZDO_UpdateNwkStatus
   \   00008E   013C         JMP     ??zapEvt_6
    386            }
    387            else
    388            {
    389              mask = evts;  // Discard unknown events - should never happen.
   \                     ??zapEvt_10:
   \   000090   0B4D         MOV.W   R13, R11
    390            }
    391          
    392            return (evts ^ mask);  // Return unprocessed events.
   \                     ??zapEvt_6:
   \   000092   0AEB         XOR.W   R11, R10
   \   000094   0C4A         MOV.W   R10, R12
   \   000096   3817         POPM.W  #0x4, R11
   \   000098   1001         RETA
    393          }
    394          
    395          /**************************************************************************************************
    396           * @fn          zapGotSync
    397           *
    398           * @brief       This function is invoked upon receipt of MT_SYS_RESET_IND or MT_UTIL_SYNC_REQ
    399           *              and would indicate that sync is (re-)gained with the ZNP.
    400           *
    401           * input parameters
    402           *
    403           * @param       port - Port Id corresponding to the ZNP that got sync.
    404           *
    405           * output parameters
    406           *
    407           * None.
    408           *
    409           * @return      None.
    410           **************************************************************************************************
    411           */

   \                                 In  segment CODE, align 2
    412          void zapGotSync(uint8 port)
   \                     zapGotSync:
    413          {
    414            zapPhySync(port);
   \   000000   ........     CALLA   #zapPhySync
    415          
    416            // Especially for UART transport, allow time for multiple got syncs before acting on it.
    417            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_SYNC_EVT, ZAP_APP_SYNC_DLY))
   \   000004   3E406400     MOV.W   #0x64, R14
   \   000008   3D400008     MOV.W   #0x800, R13
   \   00000C   5C42....     MOV.B   &zapTaskId, R12
   \   000010   ........     CALLA   #osal_start_timerEx
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   0624         JEQ     ??zapGotSync_0
    418            {
    419              (void)osal_set_event(zapTaskId, ZAP_APP_SYNC_EVT);
   \   000018   3D400008     MOV.W   #0x800, R13
   \   00001C   5C42....     MOV.B   &zapTaskId, R12
   \   000020   ........     CALLA   #osal_set_event
    420            }
    421          }
   \                     ??zapGotSync_0:
   \   000024   1001         RETA
    422          
    423          /**************************************************************************************************
    424           * @fn          zapLostSync
    425           *
    426           * @brief       This function is invoked by the PHY drivers when sync is lost with the ZNP.
    427           *
    428           * input parameters
    429           *
    430           * @param       port - Port Id corresponding to the ZNP that lost sync.
    431           *
    432           * output parameters
    433           *
    434           * None.
    435           *
    436           * @return      None.
    437           **************************************************************************************************
    438           */

   \                                 In  segment CODE, align 2
    439          void zapLostSync(uint8 port)
   \                     zapLostSync:
    440          {
    441            devState = DEV_STATE_INVALID;
   \   000000   F240FC00.... MOV.B   #0xfc, &devState
    442            znpAddr = znpParent = INVALID_NODE_ADDR;
   \   000006   B240FEFF.... MOV.W   #0xfffe, &znpParent
   \   00000C   B240FEFF.... MOV.W   #0xfffe, &znpAddr
    443            znpPanId = 0xFFFF;
   \   000012   B243....     MOV.W   #0xffff, &znpPanId
    444          }
   \   000016   1001         RETA
    445          
    446          /**************************************************************************************************
    447           * @fn          zapProcessIncoming
    448           *
    449           * @brief       This function is called by zapSysEvtMsg() to process an incoming message from ZNP.
    450           *
    451           * input parameters
    452           *
    453           * @param       port - Port Id corresponding to the ZNP that sent the message.
    454           * @param       pBuf - Pointer to event message.
    455           *
    456           * output parameters
    457           *
    458           * None.
    459           *
    460           * @return      None.
    461           **************************************************************************************************
    462           */

   \                                 In  segment CODE, align 2
    463          void zapProcessIncoming(uint8 port, uint8 *pBuf)
   \                     zapProcessIncoming:
    464          {
   \   000000   0A12         PUSH.W  R10
    465            if ((pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK) < MT_RPC_SYS_MAX)
   \   000002   5F4D0100     MOV.B   0x1(R13), R15
   \   000006   4E4F         MOV.B   R15, R14
   \   000008   7EF01F00     AND.B   #0x1f, R14
   \   00000C   7E900B00     CMP.B   #0xb, R14
   \   000010   0D2C         JC      ??zapProcessIncoming_0
    466            {
    467              zapProcessFunc_t func;
    468          
    469              if (NULL != (func = zapProcessFunc[pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK]))
   \   000012   3FF01F00     AND.W   #0x1f, R15
   \   000016   5F06         RLAM.W  #0x2, R15
   \   000018   1E4F....     MOV.W   zapProcessFunc(R15), R14
   \   00001C   1F4F....     MOV.W   zapProcessFunc + 2(R15), R15
   \   000020   0A4E         MOV.W   R14, R10
   \   000022   0ADF         BIS.W   R15, R10
   \   000024   0A93         CMP.W   #0x0, R10
   \   000026   0224         JEQ     ??zapProcessIncoming_0
    470              {
    471                func(port, pBuf);
   \   000028   ........     CALLA   #?IndCallR15
    472              }
    473            }
    474          
    475          #if ZAP_ZNP_MT
    476          #if ZAP_APP_MSG
    477            if ((MT_RPC_SYS_APP == (pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK)) &&
    478                    (MT_APP_MSG ==  pBuf[MT_RPC_POS_CMD1]))
    479            {
    480              MT_AppMsg(pBuf);
    481            }
    482            else
    483          #endif
    484            {
    485              MT_BuildAndSendZToolResponse(pBuf[MT_RPC_POS_CMD0], pBuf[MT_RPC_POS_CMD1],
    486                                           pBuf[MT_RPC_POS_LEN],  pBuf+MT_RPC_POS_DAT0);
    487            }
    488          #endif
    489          }
   \                     ??zapProcessIncoming_0:
   \   00002C   3A41         POP.W   R10
   \   00002E   1001         RETA
    490          
    491          /**************************************************************************************************
    492           * @fn          zap_msg_allocate
    493           *
    494           * @brief       This function allocates and pre-fills a dynamic RPC message buffer.
    495           *
    496           * input parameters
    497           *
    498           * @param       len - length of the data to send via RPC (i.e. not including RPC overhead.)
    499           * @param       cmd0 - a valid logical OR of the mtRpcCmdType_t & mtRpcSysType_t.
    500           * @param       cmd1 - a valid command for the mtRpcSysType_t.
    501           *
    502           * output parameters
    503           *
    504           * None.
    505           *
    506           * @return      NULL on failure to allocate all memory necessary.
    507           *              A pointer to the data area (size 'len') of a valid dynamic memory buffer on success.
    508           **************************************************************************************************
    509           */

   \                                 In  segment CODE, align 2
    510          uint8 *zap_msg_allocate(uint8 len, uint8 cmd0, uint8 cmd1)
   \                     zap_msg_allocate:
    511          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   484E         MOV.B   R14, R8
    512            // An SREQ buffer must be big enough to accept an SRSP up to the max allowable size.
    513            const uint8 sz = (MT_RPC_CMD_SREQ == (cmd0 & MT_RPC_CMD_TYPE_MASK)) ? MT_RPC_DATA_MAX : len;
   \   000008   4E4D         MOV.B   R13, R14
   \   00000A   7EF0E000     AND.B   #0xe0, R14
   \   00000E   7E902000     CMP.B   #0x20, R14
   \   000012   0320         JNE     ??zap_msg_allocate_0
   \   000014   7C40FA00     MOV.B   #0xfa, R12
   \   000018   013C         JMP     ??zap_msg_allocate_1
   \                     ??zap_msg_allocate_0:
   \   00001A   4C4A         MOV.B   R10, R12
    514            // Add space for the RPC frame header and UART transport SOP and FCS.
    515            uint8 *pBuf = (uint8 *)osal_mem_alloc(sz + MT_RPC_FRAME_HDR_SZ + 2);
   \                     ??zap_msg_allocate_1:
   \   00001C   3C500500     ADD.W   #0x5, R12
   \   000020   ........     CALLA   #osal_mem_alloc
    516          
    517            if (NULL != pBuf)
   \   000024   0C93         CMP.W   #0x0, R12
   \   000026   1424         JEQ     ??zap_msg_allocate_2
    518            {
    519              // Pre-seed the SOP for UART transport.
    520              *pBuf++ = MT_UART_SOF;
   \   000028   FC40FE000000 MOV.B   #0xfe, 0(R12)
   \   00002E   1C53         ADD.W   #0x1, R12
    521              *pBuf++ = len;
   \   000030   CC4A0000     MOV.B   R10, 0(R12)
   \   000034   1C53         ADD.W   #0x1, R12
    522              *pBuf++ = cmd0;
   \   000036   CC4B0000     MOV.B   R11, 0(R12)
   \   00003A   1C53         ADD.W   #0x1, R12
    523              *pBuf++ = cmd1;
   \   00003C   CC480000     MOV.B   R8, 0(R12)
   \   000040   1C53         ADD.W   #0x1, R12
    524              #if (3 != MT_RPC_FRAME_HDR_SZ)
    525              #error Need to port RPC frame header changes here.
    526              #endif
    527              // Pre-seed the FCS for UART transport.
    528              *(pBuf + len) = len ^ cmd0 ^ cmd1;
   \   000042   4E4A         MOV.B   R10, R14
   \   000044   4EEB         XOR.B   R11, R14
   \   000046   4EE8         XOR.B   R8, R14
   \   000048   0F4C         MOV.W   R12, R15
   \   00004A   0F5A         ADD.W   R10, R15
   \   00004C   CF4E0000     MOV.B   R14, 0(R15)
    529            }
    530          
    531            return pBuf;
   \                     ??zap_msg_allocate_2:
   \   000050   3817         POPM.W  #0x4, R11
   \   000052   1001         RETA
    532          }
    533          
    534          /**************************************************************************************************
    535           * @fn          zap_msg_deallocate
    536           *
    537           * @brief       This function deallocates an RPC message buffer created with zap_msg_allocate().
    538           *
    539           * input parameters
    540           *
    541           * @param       ppBuf - A pointer to the buffer pointer returned by zap_msg_allocate().
    542           *
    543           * output parameters
    544           *
    545           * None.
    546           *
    547           * @return      None.
    548           **************************************************************************************************
    549           */

   \                                 In  segment CODE, align 2
    550          void zap_msg_deallocate(uint8 **ppBuf)
   \                     zap_msg_deallocate:
    551          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    552            uint8 *pBuf;
    553          
    554            HAL_ASSERT(ppBuf);
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0220         JNE     ??zap_msg_deallocate_0
   \   000008   ........     CALLA   #halAssertHandler
    555          
    556            if (NULL == *ppBuf)
   \                     ??zap_msg_deallocate_0:
   \   00000C   2C4A         MOV.W   @R10, R12
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   0524         JEQ     ??zap_msg_deallocate_1
    557            {
    558              return;
    559            }
    560          
    561            pBuf = *ppBuf - (MT_RPC_FRAME_HDR_SZ + 1);
   \   000012   2C82         SUB.W   #0x4, R12
    562            *ppBuf = NULL;
   \   000014   8A430000     MOV.W   #0x0, 0(R10)
    563            osal_mem_free((void *)pBuf);
   \   000018   ........     CALLA   #osal_mem_free
    564          }
   \                     ??zap_msg_deallocate_1:
   \   00001C   3A41         POP.W   R10
   \   00001E   1001         RETA
    565          
    566          #ifdef LCD_SUPPORTED
    567          /**************************************************************************************************
    568           * @fn          zapDisInfo
    569           *
    570           * @brief       This displays the IEEE (MSB to LSB) and Network State & Address on the LCD whenever
    571           *              a change in the value is detected.
    572           *
    573           * input parameters
    574           *
    575           * None.
    576           *
    577           * output parameters
    578           *
    579           * None.
    580           *
    581           * @return      None.
    582           **************************************************************************************************
    583           */

   \                                 In  segment CODE, align 2
    584          static void zapDisInfo(void)
   \                     zapDisInfo:
    585          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801200     SUB.W   #0x12, SP
    586            uint8 i;
    587            uint8 *xad;
    588            uint8 lcd_buf[Z_EXTADDR_LEN*2+1];
    589          
    590            if (!osal_memcmp(zapDisIEEE, znpIEEE, Z_EXTADDR_LEN))
   \   000006   7A401000     MOV.B   #0x10, R10
   \   00000A   3E42         MOV.W   #0x8, R14
   \   00000C   3D40....     MOV.W   #znpIEEE, R13
   \   000010   3C40....     MOV.W   #zapDisIEEE, R12
   \   000014   ........     CALLA   #osal_memcmp
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   1E20         JNE     ??zapDisInfo_6
    591            {
    592              (void)osal_memcpy(zapDisIEEE, znpIEEE, Z_EXTADDR_LEN);
   \   00001C   3E42         MOV.W   #0x8, R14
   \   00001E   3D40....     MOV.W   #znpIEEE, R13
   \   000022   3C40....     MOV.W   #zapDisIEEE, R12
   \   000026   ........     CALLA   #osal_memcpy
    593              xad = znpIEEE + Z_EXTADDR_LEN - 1;
   \   00002A   3D40....     MOV.W   #znpIEEE + 7, R13
    594          
    595              for (i = 0; i < Z_EXTADDR_LEN*2; xad--)
   \   00002E   4843         MOV.B   #0x0, R8
   \   000030   0C41         MOV.W   SP, R12
   \   000032   0C53         ADD.W   #0x0, R12
    596              {
    597                uint8 ch;
    598                ch = (*xad >> 4) & 0x0F;
   \                     ??zapDisInfo_0:
   \   000034   6B4D         MOV.B   @R13, R11
   \   000036                RPT     #0x4
   \   000036   43194B10     RRUX.B  R11
    599                lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \   00003A   ........     CALLA   #?Subroutine4
    600                ch = *xad & 0x0F;
   \                     ??CrossCallReturnLabel_5:
   \   00003E   6B4D         MOV.B   @R13, R11
   \   000040   7BF00F00     AND.B   #0xf, R11
    601                lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \   000044   ........     CALLA   #?Subroutine4
    602              }
   \                     ??CrossCallReturnLabel_6:
   \   000048   3D53         ADD.W   #0xffff, R13
   \   00004A   489A         CMP.B   R10, R8
   \   00004C   F32B         JNC     ??zapDisInfo_0
    603              lcd_buf[Z_EXTADDR_LEN*2] = '\0';
   \   00004E   C1431000     MOV.B   #0x0, 0x10(SP)
    604              HalLcdWriteString((char *)lcd_buf, HAL_LCD_LINE_1);
   \   000052   5D43         MOV.B   #0x1, R13
   \   000054   ........     CALLA   #HalLcdWriteString
    605            }
    606          
    607            if ((zapDisState != devState) || (zapDisAddr != znpAddr))
   \                     ??zapDisInfo_6:
   \   000058   1D42....     MOV.W   &znpAddr, R13
   \   00005C   5E42....     MOV.B   &devState, R14
   \   000060   C29E....     CMP.B   R14, &zapDisState
   \   000064   0320         JNE     ??zapDisInfo_7
   \   000066   829D....     CMP.W   R13, &zapDisAddr
   \   00006A   2124         JEQ     ??zapDisInfo_8
    608            {
    609              zapDisState = devState;
   \                     ??zapDisInfo_7:
   \   00006C   C24E....     MOV.B   R14, &zapDisState
    610              zapDisAddr = znpAddr;
   \   000070   824D....     MOV.W   R13, &zapDisAddr
    611          
    612              switch (devState)
   \   000074   7E800600     SUB.B   #0x6, R14
   \   000078   0524         JEQ     ??zapDisInfo_9
   \   00007A   5E83         SUB.B   #0x1, R14
   \   00007C   0824         JEQ     ??zapDisInfo_10
   \   00007E   6E83         SUB.B   #0x2, R14
   \   000080   0B24         JEQ     ??zapDisInfo_11
   \   000082   0F3C         JMP     ??zapDisInfo_12
    613              {
    614              case DEV_END_DEVICE:
    615                HalLcdWriteStringValue("End Device", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_9:
   \   000084   6F43         MOV.B   #0x2, R15
   \   000086   4E4A         MOV.B   R10, R14
   \   000088   3C40....     MOV.W   #`?<Constant "End Device">`, R12
   \   00008C   0E3C         JMP     ??zapDisInfo_1
    616                break;
    617          
    618              case DEV_ROUTER:
    619                HalLcdWriteStringValue("ZigBee Rtr", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_10:
   \   00008E   6F43         MOV.B   #0x2, R15
   \   000090   4E4A         MOV.B   R10, R14
   \   000092   3C40....     MOV.W   #`?<Constant "ZigBee Rtr">`, R12
   \   000096   093C         JMP     ??zapDisInfo_1
    620                break;
    621          
    622              case DEV_ZB_COORD:
    623                HalLcdWriteStringValue("ZigBee Coord", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_11:
   \   000098   6F43         MOV.B   #0x2, R15
   \   00009A   4E4A         MOV.B   R10, R14
   \   00009C   3C40....     MOV.W   #`?<Constant "ZigBee Coord">`, R12
   \   0000A0   043C         JMP     ??zapDisInfo_1
    624                break;
    625          
    626              default:
    627                HalLcdWriteStringValue("Other Inval", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_12:
   \   0000A2   6F43         MOV.B   #0x2, R15
   \   0000A4   4E4A         MOV.B   R10, R14
   \   0000A6   3C40....     MOV.W   #`?<Constant "Other Inval">`, R12
   \                     ??zapDisInfo_1:
   \   0000AA   ........     CALLA   #HalLcdWriteStringValue
    628                break;
    629              }
    630            }
    631          
    632            if (zapDisPanId != znpPanId)
   \                     ??zapDisInfo_8:
   \   0000AE   1D42....     MOV.W   &znpPanId, R13
   \   0000B2   829D....     CMP.W   R13, &zapDisPanId
   \   0000B6   0924         JEQ     ??zapDisInfo_13
    633            {
    634              zapDisPanId = znpPanId;
   \   0000B8   824D....     MOV.W   R13, &zapDisPanId
    635              HalLcdWriteStringValue("PanId 0x", znpPanId, 16, HAL_LCD_LINE_3);
   \   0000BC   7F400300     MOV.B   #0x3, R15
   \   0000C0   4E4A         MOV.B   R10, R14
   \   0000C2   3C40....     MOV.W   #`?<Constant "PanId 0x">`, R12
   \   0000C6   ........     CALLA   #HalLcdWriteStringValue
    636            }
    637          }
   \                     ??zapDisInfo_13:
   \   0000CA   31501200     ADD.W   #0x12, SP
   \   0000CE   3817         POPM.W  #0x4, R11
   \   0000D0   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   4F48         MOV.B   R8, R15
   \   000002   5853         ADD.B   #0x1, R8
   \   000004   7B900A00     CMP.B   #0xa, R11
   \   000008   0328         JNC     ??zapDisInfo_2
   \   00000A   7E403700     MOV.B   #0x37, R14
   \   00000E   023C         JMP     ??zapDisInfo_3
   \                     ??zapDisInfo_2:
   \   000010   7E403000     MOV.B   #0x30, R14
   \                     ??zapDisInfo_3:
   \   000014   4B5E         ADD.B   R14, R11
   \   000016   0E4C         MOV.W   R12, R14
   \   000018   0E5F         ADD.W   R15, R14
   \   00001A   CE4B0000     MOV.B   R11, 0(R14)
   \   00001E   1001         RETA
    638          #endif
    639          
    640          /**************************************************************************************************
    641           * @fn          zapMonInfo
    642           *
    643           * @brief       This function is invoked by zapMonitor during steady state in order to maintain
    644           *              the local copies of ZNP-side global variables.
    645           *
    646           * input parameters
    647           *
    648           * None.
    649           *
    650           * output parameters
    651           *
    652           * None.
    653           *
    654           * @return      None.
    655           **************************************************************************************************
    656           */

   \                                 In  segment CODE, align 2
    657          static void zapMonInfo(void)
   \                     zapMonInfo:
    658          {
    659            static uint8 getInfoIdx;
    660          
    661            switch (getInfoIdx++)
   \   000000   5E42....     MOV.B   &??getInfoIdx, R14
   \   000004   4F4E         MOV.B   R14, R15
   \   000006   5F53         ADD.B   #0x1, R15
   \   000008   C24F....     MOV.B   R15, &??getInfoIdx
   \   00000C   4E83         SUB.B   #0x0, R14
   \   00000E   0924         JEQ     ??zapMonInfo_0
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   0C24         JEQ     ??zapMonInfo_1
   \   000014   5E83         SUB.B   #0x1, R14
   \   000016   0F24         JEQ     ??zapMonInfo_2
   \   000018   5E83         SUB.B   #0x1, R14
   \   00001A   1224         JEQ     ??zapMonInfo_3
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   2024         JEQ     ??zapMonInfo_4
   \   000020   253C         JMP     ??zapMonInfo_5
    662            {
    663            case 0:
    664              zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapMonInfo_0:
   \   000022   3D40....     MOV.W   #devState, R13
   \   000026   4C43         MOV.B   #0x0, R12
   \   000028   ........     BRA     #zb_GetDeviceInfo
    665              break;
    666            case 1:
    667              zb_GetDeviceInfo(ZB_INFO_IEEE_ADDR, &znpIEEE);
   \                     ??zapMonInfo_1:
   \   00002C   3D40....     MOV.W   #znpIEEE, R13
   \   000030   5C43         MOV.B   #0x1, R12
   \   000032   ........     BRA     #zb_GetDeviceInfo
    668              break;
    669            case 2:
    670              zb_GetDeviceInfo(ZB_INFO_SHORT_ADDR, &znpAddr);
   \                     ??zapMonInfo_2:
   \   000036   3D40....     MOV.W   #znpAddr, R13
   \   00003A   6C43         MOV.B   #0x2, R12
   \   00003C   ........     BRA     #zb_GetDeviceInfo
    671              break;
    672            case 3:
    673              zb_GetDeviceInfo(ZB_INFO_PARENT_SHORT_ADDR, &znpParent);
   \                     ??zapMonInfo_3:
   \   000040   3D40....     MOV.W   #znpParent, R13
   \   000044   7C400300     MOV.B   #0x3, R12
   \   000048   ........     CALLA   #zb_GetDeviceInfo
    674              //MHMS: Write parent address to screen 
    675              HalLcdWriteStringValue("Parent:",znpParent, 16, 6);
   \   00004C   7F400600     MOV.B   #0x6, R15
   \   000050   7E401000     MOV.B   #0x10, R14
   \   000054   1D42....     MOV.W   &znpParent, R13
   \   000058   3C40....     MOV.W   #`?<Constant "Parent:">`, R12
   \   00005C   ........     BRA     #HalLcdWriteStringValue
    676              break;
    677            case 4:
    678              zb_GetDeviceInfo(ZB_INFO_PAN_ID, &znpPanId);
   \                     ??zapMonInfo_4:
   \   000060   3D40....     MOV.W   #znpPanId, R13
   \   000064   7C400600     MOV.B   #0x6, R12
   \   000068   ........     BRA     #zb_GetDeviceInfo
    679              break;
    680            // Update ZAP_MON_INFO_CNT whenever another case is added.
    681            default:
    682          #ifdef LCD_SUPPORTED
    683              zapDisInfo();
   \                     ??zapMonInfo_5:
   \   00006C   ........     CALLA   #zapDisInfo
    684          #endif
    685              getInfoIdx = 0;
   \   000070   C243....     MOV.B   #0x0, &??getInfoIdx
    686              break;
    687            }
    688          }
   \   000074   1001         RETA

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??getInfoIdx:
   \   000000                DS8 1
    689          
    690          #if ZAP_APP_KEYS
    691          /**************************************************************************************************
    692           * @fn          zapKeys
    693           *
    694           * @brief       This function is called by zapSysEvtMsg() to process a key(s) event.
    695           *
    696           * input parameters
    697           *
    698           * None.
    699           *
    700           * output parameters
    701           *
    702           * None.
    703           *
    704           * @return      None.
    705          * MHMS:SW1 and SW2 here are currently set to change the logical type of the Zigbee node.
    706          *MHMS: SW3 and SW4 currently permit and deny joining
    707           **************************************************************************************************
    708           */

   \                                 In  segment CODE, align 2
    709          static void zapKeys(keyChange_t *msg)
   \                     zapKeys:
    710          {
   \   000000   1B15         PUSHM.W #0x2, R11
    711            const uint8 keys = msg->keys;
   \   000002   5A4C0300     MOV.B   0x3(R12), R10
    712          
    713            if (msg->state)  // Shift key.
   \   000006   7B400700     MOV.B   #0x7, R11
   \   00000A   CC930200     CMP.B   #0x0, 0x2(R12)
   \   00000E   1724         JEQ     ??zapKeys_0
    714            {
    715              if (keys & HAL_KEY_SW_1)
   \   000010   5AB3         BIT.B   #0x1, R10
   \   000012   0528         JNC     ??zapKeys_1
    716                //MHMS:
    717                HalLcdWriteString("HELLO AGAIN WORLD",HAL_LCD_LINE_7);
   \   000014   4D4B         MOV.B   R11, R13
   \   000016   3C40....     MOV.W   #`?<Constant "HELLO AGAIN WORLD">`, R12
   \   00001A   ........     CALLA   #HalLcdWriteString
    718              {
    719              }
    720              if (keys & HAL_KEY_SW_2)
    721              {
    722              }
    723              if (keys & HAL_KEY_SW_3)
    724              {
    725              }
    726              if (keys & HAL_KEY_SW_4)
    727              {
    728              }
    729              if (keys &HAL_KEY_SW_7){ //S2 + S1 (shift key) on the EXP board
   \                     ??zapKeys_1:
   \   00001E   7AB04000     BIT.B   #0x40, R10
   \   000022   4F28         JNC     ??zapKeys_2
    730                //MHMS:  Stop sending Test Payload data, But allow check in event
    731                osal_set_event(pulseTaskId, PULSE_EVT_CHECKIN);
   \   000024   3D400008     MOV.W   #0x800, R13
   \   000028   5C42....     MOV.B   &pulseTaskId, R12
   \   00002C   ........     CALLA   #osal_set_event
    732                osal_stop_timerEx(pulseTaskId, TEST_EVT_PAYLOAD_TX);
   \   000030   3D400004     MOV.W   #0x400, R13
   \   000034   5C42....     MOV.B   &pulseTaskId, R12
   \   000038   ........     CALLA   #osal_stop_timerEx
   \   00003C   423C         JMP     ??zapKeys_2
    733              }
    734            }
    735            else
    736            {
    737              if (keys & HAL_KEY_SW_1)
   \                     ??zapKeys_0:
   \   00003E   5AB3         BIT.B   #0x1, R10
   \   000040   0D28         JNC     ??zapKeys_3
    738              {
    739                //MHMS:SW1 type change to coordinator
    740                if(zap_set_logicalType(ZG_DEVICETYPE_COORDINATOR)){
   \   000042   4C43         MOV.B   #0x0, R12
   \   000044   ........     CALLA   #zap_set_logicalType
   \   000048   4C93         CMP.B   #0x0, R12
   \   00004A   4D4B         MOV.B   R11, R13
   \   00004C   0324         JEQ     ??zapKeys_4
    741                HalLcdWriteString("Should be Coord.",HAL_LCD_LINE_7);
   \   00004E   3C40....     MOV.W   #`?<Constant "Should be Coord.">`, R12
   \   000052   023C         JMP     ??zapKeys_5
    742                }
    743                else{
    744                HalLcdWriteString("Problem Writing",HAL_LCD_LINE_7);
   \                     ??zapKeys_4:
   \   000054   3C40....     MOV.W   #`?<Constant "Problem Writing">`, R12
   \                     ??zapKeys_5:
   \   000058   ........     CALLA   #HalLcdWriteString
    745                }
    746              }
    747              if (keys & HAL_KEY_SW_2)
   \                     ??zapKeys_3:
   \   00005C   6AB3         BIT.B   #0x2, R10
   \   00005E   0D28         JNC     ??zapKeys_6
    748              {
    749               //MHMS: Try and implement ZdoStateChange to Router
    750               if(zap_set_logicalType(ZG_DEVICETYPE_ROUTER)){
   \   000060   5C43         MOV.B   #0x1, R12
   \   000062   ........     CALLA   #zap_set_logicalType
   \   000066   4C93         CMP.B   #0x0, R12
   \   000068   4D4B         MOV.B   R11, R13
   \   00006A   0324         JEQ     ??zapKeys_7
    751                HalLcdWriteString("Should be Router",HAL_LCD_LINE_7);
   \   00006C   3C40....     MOV.W   #`?<Constant "Should be Router">`, R12
   \   000070   023C         JMP     ??zapKeys_8
    752                }
    753                else{
    754                HalLcdWriteString("Problem Writing", HAL_LCD_LINE_7);
   \                     ??zapKeys_7:
   \   000072   3C40....     MOV.W   #`?<Constant "Problem Writing">`, R12
   \                     ??zapKeys_8:
   \   000076   ........     CALLA   #HalLcdWriteString
    755                }
    756              }
    757              if (keys & HAL_KEY_SW_3)
   \                     ??zapKeys_6:
   \   00007A   7AB01000     BIT.B   #0x10, R10
   \   00007E   0B28         JNC     ??zapKeys_9
    758              {
    759                if(zb_PermitJoiningRequest(znpAddr,0x00)){
   \   000080   4D43         MOV.B   #0x0, R13
   \   000082   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_8:
   \   000086   0324         JEQ     ??zapKeys_10
    760                  HalLcdWriteString("Permissions Problem",HAL_LCD_LINE_7);
   \   000088   3C40....     MOV.W   #`?<Constant "Permissions Problem">`, R12
   \   00008C   023C         JMP     ??zapKeys_11
    761                }
    762                else{
    763                  HalLcdWriteString("No more Joining", HAL_LCD_LINE_7);
   \                     ??zapKeys_10:
   \   00008E   3C40....     MOV.W   #`?<Constant "No more Joining">`, R12
   \                     ??zapKeys_11:
   \   000092   ........     CALLA   #HalLcdWriteString
    764                }
    765              }
    766              if (keys & HAL_KEY_SW_4)
   \                     ??zapKeys_9:
   \   000096   7AB2         BIT.B   #0x8, R10
   \   000098   0B28         JNC     ??zapKeys_12
    767              {
    768                if(zb_PermitJoiningRequest(znpAddr,0xFF)){
   \   00009A   7D43         MOV.B   #0xff, R13
   \   00009C   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_9:
   \   0000A0   0324         JEQ     ??zapKeys_13
    769                  HalLcdWriteString("Permissions Problem", HAL_LCD_LINE_7);
   \   0000A2   3C40....     MOV.W   #`?<Constant "Permissions Problem">`, R12
   \   0000A6   023C         JMP     ??zapKeys_14
    770                }
    771                else{
    772                  HalLcdWriteString("Should Join Now",HAL_LCD_LINE_7);
   \                     ??zapKeys_13:
   \   0000A8   3C40....     MOV.W   #`?<Constant "Should Join Now">`, R12
   \                     ??zapKeys_14:
   \   0000AC   ........     CALLA   #HalLcdWriteString
    773                }
    774              }
    775              if (keys &HAL_KEY_SW_7){ //S2 on the EXP board
   \                     ??zapKeys_12:
   \   0000B0   7AB04000     BIT.B   #0x40, R10
   \   0000B4   0628         JNC     ??zapKeys_2
    776                //MHMS:  Start sending Test payload data
    777                osal_set_event(pulseTaskId, TEST_EVT_PAYLOAD_TX);
   \   0000B6   3D400004     MOV.W   #0x400, R13
   \   0000BA   5C42....     MOV.B   &pulseTaskId, R12
   \   0000BE   ........     CALLA   #osal_set_event
    778              
    779              }
    780                  
    781            }
    782          }
   \                     ??zapKeys_2:
   \   0000C2   1A17         POPM.W  #0x2, R11
   \   0000C4   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   1C42....     MOV.W   &znpAddr, R12
   \   000004   ........     CALLA   #zb_PermitJoiningRequest
   \   000008   4C93         CMP.B   #0x0, R12
   \   00000A   4D4B         MOV.B   R11, R13
   \   00000C   1001         RETA
    783          #endif
    784          
    785          /**************************************************************************************************
    786           * @fn          zapMonitor
    787           *
    788           * @brief       This function is called by OSAL timer or event to monitor the ZNP for all.
    789           *
    790           * input parameters
    791           *
    792           * None.
    793           *
    794           * output parameters
    795           *
    796           * None.
    797           *
    798           * @return      None.
    799           **************************************************************************************************
    800           */

   \                                 In  segment CODE, align 2, keep-with-next
    801          static void zapMonitor(void)
   \                     zapMonitor:
    802          {
    803            /* If the ZNP has not already reported by the first monitor run, only the ZAP has reset and not
    804             * the ZNP; or the ZAP/ZNP sync has been lost.
    805             */
    806            if (DEV_STATE_INVALID == devState)
   \   000000   5E42....     MOV.B   &devState, R14
   \   000004   7E90FC00     CMP.B   #0xfc, R14
   \   000008   0A20         JNE     ??zapMonitor_1
    807            {
    808          #if ZAP_APP_LED
    809              HalLedSet (HAL_LED_2, HAL_LED_MODE_OFF);
    810          #endif
    811              devState = DEV_STATE_SYNC_LOST;
   \   00000A   F240FD00.... MOV.B   #0xfd, &devState
    812              zapUtilReq(MT_UTIL_SYNC_REQ, NULL, NULL);
   \   000010   0E43         MOV.W   #0x0, R14
   \   000012   0D43         MOV.W   #0x0, R13
   \   000014   7C40E000     MOV.B   #0xe0, R12
   \   000018   ........     CALLA   #zapUtilReq
   \   00001C   1E3C         JMP     ??zapMonitor_2
    813            }
    814            else if (DEV_STATE_SYNC_LOST == devState)
   \                     ??zapMonitor_1:
   \   00001E   7E90FD00     CMP.B   #0xfd, R14
   \   000022   0720         JNE     ??zapMonitor_3
    815            {
    816              devState = DEV_STATE_ZNP_LOST;
   \   000024   F240FE00.... MOV.B   #0xfe, &devState
    817              znpSystemReset(ZNP_RESET_SOFT);
   \   00002A   5C43         MOV.B   #0x1, R12
   \   00002C   ........     CALLA   #znpSystemReset
   \   000030   143C         JMP     ??zapMonitor_2
    818            }
    819            else if (DEV_STATE_ZNP_LOST == devState)
   \                     ??zapMonitor_3:
   \   000032   7E90FE00     CMP.B   #0xfe, R14
   \   000036   0720         JNE     ??zapMonitor_4
    820            {
    821              devState = DEV_STATE_ZAP_LOST;
   \   000038   F243....     MOV.B   #0xff, &devState
    822              zapPhyReset(zapAppPort);
   \   00003C   5C42....     MOV.B   &zapAppPort, R12
   \   000040   ........     CALLA   #zapPhyReset
   \   000044   0A3C         JMP     ??zapMonitor_2
    823            }
    824            else if (DEV_STATE_ZAP_LOST == devState)
   \                     ??zapMonitor_4:
   \   000046   7E93         CMP.B   #0xff, R14
   \   000048   0620         JNE     ??zapMonitor_5
    825            {
    826              HalReset();
   \   00004A   32C2         dint
   \   00004C   0343         nop
   \   00004E   B24004A52001 MOV.W   #0xa504, &0x120
   \   000054   023C         JMP     ??zapMonitor_2
    827            }
    828            else
    829            {
    830          #if ZAP_APP_LED
    831              HalLedSet (HAL_LED_2, HAL_LED_MODE_ON);
    832          #endif
    833              zapMonInfo();
   \                     ??zapMonitor_5:
   \   000056   ........     CALLA   #zapMonInfo
    834            }
    835          
    836            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_TMR_EVT, ZAP_APP_TMR_DLY))
   \                     ??zapMonitor_2:
   \   00005A                REQUIRE ?Subroutine1
   \   00005A                REQUIRE _A_PMMCTL0_L
   \   00005A                // Fall through to label ?Subroutine1
    837            {
    838              (void)osal_set_event(zapTaskId, ZAP_APP_TMR_EVT);
    839            }
    840          
    841          #if ZAP_APP_LED
    842            HalLedSet (HAL_LED_4, HAL_LED_MODE_TOGGLE);
    843          #endif
    844          }
    845          
    846          /**************************************************************************************************
    847           * @fn          zapSync
    848           *
    849           * @brief       This function is invoked upon receipt of ZAP_APP_SYNC_EVT.
    850           *
    851           * input parameters
    852           *
    853           * None.
    854           *
    855           * output parameters
    856           *
    857           * None.
    858           *
    859           * @return      None.
    860           **************************************************************************************************
    861           */

   \                                 In  segment CODE, align 2
   \                     ??Subroutine8_0:
   \   000000   5E43         MOV.B   #0x1, R14
   \   000002   4D43         MOV.B   #0x0, R13
   \   000004   3C400300     MOV.W   #0x3, R12
   \   000008   ........     BRA     #znp_nv_write

   \                                 In  segment CODE, align 2
    862          static void zapSync(void)
   \                     zapSync:
    863          {
   \   000000   0A12         PUSH.W  R10
   \   000002   3182         SUB.W   #0x8, SP
    864            uint8 pBuf[Z_EXTADDR_LEN];
    865          
    866          #if ZAP_NV_RESTORE
    867            pBuf[0] = ZCD_STARTOPT_AUTO_START;
    868            (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
    869          #else
    870            (void)osal_memset(pBuf, 0, Z_EXTADDR_LEN);
   \   000004   0A41         MOV.W   SP, R10
   \   000006   0A53         ADD.W   #0x0, R10
   \   000008   3E42         MOV.W   #0x8, R14
   \   00000A   4D43         MOV.B   #0x0, R13
   \   00000C   0C4A         MOV.W   R10, R12
   \   00000E   ........     CALLA   #osal_memset
    871            if (osal_memcmp(pBuf, znpIEEE, Z_EXTADDR_LEN))
   \   000012   3E42         MOV.W   #0x8, R14
   \   000014   3D40....     MOV.W   #znpIEEE, R13
   \   000018   0C4A         MOV.W   R10, R12
   \   00001A   ........     CALLA   #osal_memcmp
   \   00001E   4C93         CMP.B   #0x0, R12
   \   000020   1024         JEQ     ??zapSync_0
    872            {
    873              zb_GetDeviceInfo(ZB_INFO_IEEE_ADDR, &znpIEEE);
   \   000022   3D40....     MOV.W   #znpIEEE, R13
   \   000026   5C43         MOV.B   #0x1, R12
   \   000028   ........     CALLA   #zb_GetDeviceInfo
    874              pBuf[0] = ZCD_STARTOPT_CLEAR_STATE | ZCD_STARTOPT_CLEAR_CONFIG;
   \   00002C   F14003000000 MOV.B   #0x3, 0(SP)
    875              (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
   \   000032   0F4A         MOV.W   R10, R15
   \   000034   ........     CALLA   #??Subroutine8_0
    876              zapPhyReset(zapAppPort);
   \                     ??CrossCallReturnLabel_12:
   \   000038   5C42....     MOV.B   &zapAppPort, R12
   \   00003C   ........     CALLA   #zapPhyReset
    877              return;
   \   000040   353C         JMP     ??zapSync_1
    878            }
    879          #endif
    880          
    881            zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapSync_0:
   \   000042   ........     CALLA   #?Subroutine5
    882            zapAfSync();
   \                     ??CrossCallReturnLabel_7:
   \   000046   ........     CALLA   #zapAfSync
    883            zapZdoSync();
   \   00004A   ........     CALLA   #zapZdoSync
    884          #if !ZAP_PHY_RESET_ZNP
    885            // If ZAP resets while a connected ZNP is left running, the ZNP cannot be expected to issue a
    886            // ZDO_STATE_CHANGE notification.
    887            if ((DEV_END_DEVICE == devState) || (DEV_ROUTER == devState) || (DEV_ZB_COORD == devState))
    888            {
    889              // Especially for UART transport, allow time for multiple got syncs before acting on it.
    890              if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_ZDO_STATE_CHANGE_EVT,
    891                                                            ZAP_APP_ZDO_STATE_CHANGE_DLY))
    892              {
    893                (void)osal_set_event(zapTaskId, ZAP_APP_ZDO_STATE_CHANGE_EVT);
    894              }
    895            }
    896          #endif
    897          #if ZAP_AUTO_CFG
    898            if (devState < DEV_END_DEVICE)
   \   00004E   F2900600.... CMP.B   #0x6, &devState
   \   000054   1C2C         JC      ??zapSync_2
    899            {
    900              // Configure the defaults from zap.cfg into the ZNP.
    901              //pBuf[0] = ZAP_DEVICETYPE;
    902              //MHMS:fixing zapsync using global variable
    903              pBuf[0] = zLogicalType;
   \   000056   D142....0000 MOV.B   &zLogicalType, 0(SP)
    904              (void)znp_nv_write(ZCD_NV_LOGICAL_TYPE, 0, 1, pBuf);
   \   00005C   0F4A         MOV.W   R10, R15
   \   00005E   ........     CALLA   #?Subroutine2
    905              //MHMS: CHANGING PANID HERE
    906              pBuf[0] = LO_UINT16(ZDAPP_CONFIG_PAN_ID);
   \                     ??CrossCallReturnLabel_1:
   \   000062   F1430000     MOV.B   #0xff, 0(SP)
    907              pBuf[1] = HI_UINT16(ZDAPP_CONFIG_PAN_ID);
   \   000066   F1430100     MOV.B   #0xff, 0x1(SP)
    908              (void)znp_nv_write(ZCD_NV_PANID, 0, 2, pBuf);
   \   00006A   0F4A         MOV.W   R10, R15
   \   00006C   ........     CALLA   #?Subroutine3
    909          
    910              pBuf[0] = BREAK_UINT32(DEFAULT_CHANLIST, 0);
   \                     ??CrossCallReturnLabel_3:
   \   000070   C1430000     MOV.B   #0x0, 0(SP)
    911              pBuf[1] = BREAK_UINT32(DEFAULT_CHANLIST, 1);
   \   000074   F1420100     MOV.B   #0x8, 0x1(SP)
    912              pBuf[2] = BREAK_UINT32(DEFAULT_CHANLIST, 2);
   \   000078   C1430200     MOV.B   #0x0, 0x2(SP)
    913              pBuf[3] = BREAK_UINT32(DEFAULT_CHANLIST, 3);
   \   00007C   C1430300     MOV.B   #0x0, 0x3(SP)
    914              (void)znp_nv_write(ZCD_NV_CHANLIST, 0, 4, pBuf);
   \   000080   0F4A         MOV.W   R10, R15
   \   000082   6E42         MOV.B   #0x4, R14
   \   000084   4D43         MOV.B   #0x0, R13
   \   000086   3C408400     MOV.W   #0x84, R12
   \   00008A   ........     CALLA   #znp_nv_write
    915              
    916            }
    917          #endif
    918          #if defined TC_LINKKEY_JOIN
    919            zapCertSync();
    920          #endif
    921          #if ZAP_AUTO_START
    922            if ((DEV_HOLD == devState) || (DEV_INIT == devState) || (DEV_NWK_ORPHAN == devState))
   \                     ??zapSync_2:
   \   00008E   5E42....     MOV.B   &devState, R14
   \   000092   4E93         CMP.B   #0x0, R14
   \   000094   0524         JEQ     ??zapSync_3
   \   000096   5E93         CMP.B   #0x1, R14
   \   000098   0324         JEQ     ??zapSync_3
   \   00009A   7E900A00     CMP.B   #0xa, R14
   \   00009E   0420         JNE     ??zapSync_4
    923            {
    924              (void)ZDOInitDevice(NWK_START_DELAY);
   \                     ??zapSync_3:
   \   0000A0   3C406400     MOV.W   #0x64, R12
   \   0000A4   ........     CALLA   #ZDOInitDevice
    925            }
    926          #endif
    927            zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapSync_4:
   \   0000A8   ........     CALLA   #?Subroutine5
    928          }
   \                     ??zapSync_1:
   \   0000AC   3152         ADD.W   #0x8, SP
   \   0000AE   3A41         POP.W   R10
   \   0000B0   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   3D40....     MOV.W   #devState, R13
   \   000004   4C43         MOV.B   #0x0, R12
   \   000006   ........     BRA     #zb_GetDeviceInfo

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   6E43         MOV.B   #0x2, R14
   \   000002   4D43         MOV.B   #0x0, R13
   \   000004   3C408300     MOV.W   #0x83, R12
   \   000008   ........     BRA     #znp_nv_write

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   5E43         MOV.B   #0x1, R14
   \   000002   4D43         MOV.B   #0x0, R13
   \   000004   3C408700     MOV.W   #0x87, R12
   \   000008   ........     BRA     #znp_nv_write
    929          
    930          /**************************************************************************************************
    931           * @fn          zapSysEvtMsg
    932           *
    933           * @brief       This function is called by zapEvt() to process all of the pending OSAL messages.
    934           *
    935           * input parameters
    936           *
    937           * None.
    938           *
    939           * output parameters
    940           *
    941           * None.
    942           *
    943           * @return      None.
    944           **************************************************************************************************
    945           */
    946          static void zapSysEvtMsg(void)
    947          {
    948            uint8 *msg;
    949          
    950            while ((msg = osal_msg_receive(zapTaskId)))
    951            {
    952              switch (*msg)
    953              {
    954              case CMD_SERIAL_MSG:
    955                zapProcessIncoming(((mtOSALSerialData_t *)msg)->hdr.status, ((mtOSALSerialData_t *)msg)->msg);
    956                break;
    957          
    958          #if ZAP_APP_KEYS
    959              case KEY_CHANGE:
    960                zapKeys((keyChange_t *)msg);
    961                break;
    962          #endif
    963          
    964              default:
    965                break;
    966              }
    967          
    968              (void)osal_msg_deallocate(msg);  // Receiving task is responsible for releasing the memory.
    969            }
    970          }
    971          
    972          #if ZAP_ZNP_MT
    973          /**************************************************************************************************
    974           * @fn          MT_BuildAndSendZToolResponse
    975           *
    976           * @brief       This function is the ZAP proxy to the ZNP SystemReset() functionality.
    977           *
    978           * input parameters
    979           *
    980           * @param       cmdType - include type and subsystem
    981           * @param       cmdId - command ID
    982           * @param       dataLen
    983           * @param       *pData
    984           *
    985           * output parameters
    986           *
    987           * None.
    988           *
    989           * @return      None.
    990           **************************************************************************************************
    991           */
    992          void MT_BuildAndSendZToolResponse(uint8 cmdType, uint8 cmdId, uint8 dataLen, uint8 *pData)
    993          {
    994            uint8 *pBuf = zap_msg_allocate(dataLen, cmdType, cmdId);
    995          
    996            if (NULL != pBuf)
    997            {
    998              (void)osal_memcpy(pBuf, pData, dataLen);
    999              zapPhyUartSend(zapAppPort, pBuf);
   1000              zap_msg_deallocate(&pBuf);
   1001            }
   1002          }
   1003          #endif
   1004          //MHMS: Making function to set logical type

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   0F4B         MOV.W   R11, R15
   \   000002                REQUIRE ??Subroutine8_0
   \   000002                // Fall through to label ??Subroutine8_0

   \                                 In  segment CODE, align 2
   1005          bool zap_set_logicalType(uint8 newType)
   \                     zap_set_logicalType:
   1006          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   4A4C         MOV.B   R12, R10
   1007                    uint8 pBuf[Z_EXTADDR_LEN];
   1008                    
   1009                    //very important to make sure STARTOPT_CONFIG_STATE is clear
   1010                    pBuf[0] = ZCD_STARTOPT_CLEAR_STATE;
   \   000006   E1430000     MOV.B   #0x2, 0(SP)
   1011                    (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
   \   00000A   0B41         MOV.W   SP, R11
   \   00000C   0B53         ADD.W   #0x0, R11
   \   00000E   ........     CALLA   #?Subroutine0
   1012                    quickReset();
   \                     ??CrossCallReturnLabel_14:
   \   000012   ........     CALLA   #quickReset
   1013                    
   1014                    //set to auto start?
   1015                    pBuf[0] = ZCD_STARTOPT_AUTO_START;
   \   000016   E1420000     MOV.B   #0x4, 0(SP)
   1016                    (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
   \   00001A   ........     CALLA   #?Subroutine0
   1017                    
   1018                    //Set Default PanId (0xFFFF)
   1019                    pBuf[0] = LO_UINT16(ZDAPP_CONFIG_PAN_ID);
   \                     ??CrossCallReturnLabel_13:
   \   00001E   F1430000     MOV.B   #0xff, 0(SP)
   1020                    pBuf[1] = HI_UINT16(ZDAPP_CONFIG_PAN_ID);
   \   000022   F1430100     MOV.B   #0xff, 0x1(SP)
   1021                    (void)znp_nv_write(ZCD_NV_PANID, 0, 2, pBuf);
   \   000026   0F4B         MOV.W   R11, R15
   \   000028   ........     CALLA   #?Subroutine3
   1022                    quickReset();
   \                     ??CrossCallReturnLabel_4:
   \   00002C   ........     CALLA   #quickReset
   1023                    zLogicalType=newType;
   \   000030   C24A....     MOV.B   R10, &zLogicalType
   1024                    (void)znp_nv_write(ZCD_NV_LOGICAL_TYPE, 0, 1, pBuf);
   \   000034   0F4B         MOV.W   R11, R15
   \   000036   ........     CALLA   #?Subroutine2
   1025                    quickReset();
   \                     ??CrossCallReturnLabel_2:
   \   00003A   ........     CALLA   #quickReset
   1026                   //(void)ZDOInitDevice(NWK_START_DELAY);
   1027                    //Realistically nothing returns from here...
   1028                    return 1;       
   \   00003E   5C43         MOV.B   #0x1, R12
   \   000040   3152         ADD.W   #0x8, SP
   \   000042   1A17         POPM.W  #0x2, R11
   \   000044   1001         RETA
   1029          }
   1030          /**************************************************************************************************
   1031          */
   1032          //MHMS: Had to make this to handle API commands outside of scope of this demo.
   1033          /*
   1034          void makeRPC(uint8 length, uint8 cmd0,uint8 cmd1,uint8 * args){
   1035           
   1036            uint8 *pBuf = zap_msg_allocate(length, 0x25, 0x34);
   1037            if (NULL != pBuf)
   1038            {
   1039              (void)osal_memcpy(pBuf,args,length);
   1040              zapPhySend(zapAppPort, pBuf);
   1041              zap_msg_deallocate(&pBuf);
   1042            }
   1043          }*/
   1044          //MHMS: skips lostSync in ZapPhyReset

   \                                 In  segment CODE, align 2
   1045          void quickReset(void){
   \                     quickReset:
   1046            HAL_ZNP_RST();
   \   000000   E2C20202     BIC.B   #0x4, &0x202
   1047            MicroWait(100);
   \   000004   3C406400     MOV.W   #0x64, R12
   \   000008   ........     CALLA   #Onboard_wait
   1048            HAL_ZNP_RUN();
   \   00000C   E2D20202     BIS.B   #0x4, &0x202
   1049          }
   \   000010   1001         RETA
   \   000012                REQUIRE _A_PAOUT_L

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for zLogicalType>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "End Device">`:
   \   000000   456E64204465 DC8 "End Device"
   \            7669636500  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "ZigBee Rtr">`:
   \   000000   5A6967426565 DC8 "ZigBee Rtr"
   \            2052747200  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "ZigBee Coord">`:
   \   000000   5A6967426565 DC8 "ZigBee Coord"
   \            20436F6F7264
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Other Inval">`:
   \   000000   4F7468657220 DC8 "Other Inval"
   \            496E76616C00

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "PanId 0x">`:
   \   000000   50616E496420 DC8 "PanId 0x"
   \            307800      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Parent:">`:
   \   000000   506172656E74 DC8 "Parent:"
   \            3A00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "HELLO AGAIN WORLD">`:
   \   000000   48454C4C4F20 DC8 "HELLO AGAIN WORLD"
   \            414741494E20
   \            574F524C4400

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Should be Coord.">`:
   \   000000   53686F756C64 DC8 "Should be Coord."
   \            20626520436F
   \            6F72642E00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Problem Writing">`:
   \   000000   50726F626C65 DC8 "Problem Writing"
   \            6D2057726974
   \            696E6700    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Should be Router">`:
   \   000000   53686F756C64 DC8 "Should be Router"
   \            20626520526F
   \            7574657200  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Permissions Problem">`:
   \   000000   5065726D6973 DC8 "Permissions Problem"
   \            73696F6E7320
   \            50726F626C65
   \            6D00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "No more Joining">`:
   \   000000   4E6F206D6F72 DC8 "No more Joining"
   \            65204A6F696E
   \            696E6700    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Should Join Now">`:
   \   000000   53686F756C64 DC8 "Should Join Now"
   \            204A6F696E20
   \            4E6F7700    

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  quickReset
             4 -> Onboard_wait
      30  zapDisInfo
            30 -> HalLcdWriteString
            30 -> HalLcdWriteStringValue
            30 -> osal_memcmp
            30 -> osal_memcpy
      12  zapEvt
            12 -> ZDO_UpdateNwkStatus
            12 -> osal_msg_deallocate
            12 -> osal_msg_receive
            12 -> zapKeys
            12 -> zapMonInfo
            12 -> zapMonitor
            12 -> zapPhyExec
            12 -> zapProcessIncoming
            12 -> zapSync
       4  zapGotSync
             4 -> osal_set_event
             4 -> osal_start_timerEx
             4 -> zapPhySync
       6  zapInit
             6 -> RegisterForKeys
             6 -> osal_set_event
             6 -> osal_start_timerEx
             6 -> zapLostSync
             6 -> zapPhyInit
       8  zapKeys
             8 -> HalLcdWriteString
             8 -> osal_set_event
             8 -> osal_stop_timerEx
             8 -> zap_set_logicalType
             8 -> zb_PermitJoiningRequest
       4  zapLostSync
       4  zapMonInfo
             4 -> HalLcdWriteStringValue
             4 -> zapDisInfo
             4 -> zb_GetDeviceInfo
       4  zapMonitor
             4 -> osal_set_event
             4 -> osal_start_timerEx
             4 -> zapMonInfo
             4 -> zapPhyReset
             4 -> zapUtilReq
             4 -> znpSystemReset
       6  zapProcessIncoming
             6 -- Indirect call
      14  zapSync
            14 -> ZDOInitDevice
            14 -> osal_memcmp
            14 -> osal_memset
            14 -> zapAfSync
            14 -> zapPhyReset
            14 -> zapZdoSync
            14 -> zb_GetDeviceInfo
            14 -> znp_nv_write
      12  zap_msg_allocate
            12 -> osal_mem_alloc
       6  zap_msg_deallocate
             6 -> halAssertHandler
             6 -> osal_mem_free
      16  zap_set_logicalType
            16 -> quickReset
            16 -> znp_nv_write
      10  zgWriteStartupOptions
            10 -> osal_nv_read
            10 -> osal_nv_write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "End Device">
      18  ?<Constant "HELLO AGAIN WORLD">
      16  ?<Constant "No more Joining">
      12  ?<Constant "Other Inval">
       9  ?<Constant "PanId 0x">
       8  ?<Constant "Parent:">
      20  ?<Constant "Permissions Problem">
      16  ?<Constant "Problem Writing">
      16  ?<Constant "Should Join Now">
      17  ?<Constant "Should be Coord.">
      17  ?<Constant "Should be Router">
      13  ?<Constant "ZigBee Coord">
      11  ?<Constant "ZigBee Rtr">
       1  ?<Initializer for zLogicalType>
      12  ??Subroutine8_0
       2  ?Subroutine0
      34  ?Subroutine1
      12  ?Subroutine2
      12  ?Subroutine3
      32  ?Subroutine4
      10  ?Subroutine5
      14  ?Subroutine6
      14  ?Subroutine7
       2  _A_PAOUT_L
       2  _A_PMMCTL0_L
       1  devState
       1  getInfoIdx
      18  quickReset
       1  zLogicalType
       1  zapAppPort
       2  zapDisAddr
       8  zapDisIEEE
     210  zapDisInfo
       2  zapDisPanId
       1  zapDisState
     154  zapEvt
      38  zapGotSync
      36  zapInit
     198  zapKeys
      24  zapLostSync
     118  zapMonInfo
      90  zapMonitor
      40  zapProcessFunc
      48  zapProcessIncoming
     178  zapSync
       1  zapTaskId
      84  zap_msg_allocate
      32  zap_msg_deallocate
      70  zap_set_logicalType
       2  zgTrustCenterAddr
      54  zgWriteStartupOptions
       2  znpAddr
       8  znpIEEE
       2  znpPanId
       2  znpParent

 
 1 494 bytes in segment CODE
     4 bytes in segment DATA16_AN
   224 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    33 bytes in segment DATA16_Z
 
 1 494 bytes of CODE  memory
   225 bytes of CONST memory
    34 bytes of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: none
