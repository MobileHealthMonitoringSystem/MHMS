###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       07/Apr/2013  00:34:04 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\Source\zap_app.c                   #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=0                    #
#                     -DZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER                   #
#                     -DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1 -DHAL_UART=1    #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\Source\zap_app.c -lC               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\ -lA  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\      #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\       #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\zap_a #
#                     pp.lst                                                  #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\zap_ap #
#                     p.r43                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\Source\zap_app.c
      1          /**************************************************************************************************
      2              Filename:       zap_app.c
      3              Revised:        $Date: 2011-07-05 11:35:58 -0700 (Tue, 05 Jul 2011) $
      4              Revision:       $Revision: 26589 $
      5          
      6              Description:
      7          
      8              This file defines the functionality of the ZNP Application Processor.
      9          
     10          
     11              Copyright 2009-2011 Texas Instruments Incorporated. All rights reserved.
     12          
     13              IMPORTANT: Your use of this Software is limited to those specific rights
     14              granted under the terms of a software license agreement between the user
     15              who downloaded the software, his/her employer (which must be your employer)
     16              and Texas Instruments Incorporated (the "License").  You may not use this
     17              Software unless you agree to abide by the terms of the License. The License
     18              limits your use, and you acknowledge, that the Software may not be modified,
     19              copied or distributed unless embedded on a Texas Instruments microcontroller
     20              or used solely and exclusively in conjunction with a Texas Instruments radio
     21              frequency transceiver, which is integrated into your product.  Other than for
     22              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23              works of, modify, distribute, perform, display or sell this Software and/or
     24              its documentation for any purpose.
     25          
     26              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38              Should you have any questions regarding your right to use this Software,
     39              contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "hal_board.h"

   \                                 In  segment DATA16_AN, at 0x120
   \   union <unnamed> _A_PMMCTL0_L
   \                     _A_PMMCTL0_L:
   \   000000                DS8 2
     48          #include "hal_key.h"
     49          #include "hal_lcd.h"
     50          #include "hal_led.h"
     51          #include "mt.h"
     52          #include "mt_rpc.h"
     53          #include "mt_sys.h"
     54          #include "mt_uart.h"
     55          #include "OSAL.h"
     56          #include "OSAL_Tasks.h"
     57          //MHMS: Inlude NV memory read and write stuff
     58          #include "OSAL_Nv.h"
     59          #include "sapi.h"
     60          #include "zap_app.h"
     61          #include "zap_phy.h"
     62          #include "zap_znp.h"
     63          #include "ZDApp.h"
     64          #include "ZDObject.h"
     65          #include "ZComDef.h"
     66          
     67          /* ------------------------------------------------------------------------------------------------
     68           *                                           Constants
     69           * ------------------------------------------------------------------------------------------------
     70           */
     71          
     72          #if !defined ZAP_APP_PORT
     73          #define ZAP_APP_PORT  0
     74          #endif
     75          
     76          #if !defined ZAP_APP_LED
     77          #define ZAP_APP_LED   FALSE
     78          #endif
     79          
     80          #if !defined ZAP_APP_KEYS
     81          #define ZAP_APP_KEYS  TRUE
     82          #endif
     83          
     84          /* ------------------------------------------------------------------------------------------------
     85           *                                           Typedefs
     86           * ------------------------------------------------------------------------------------------------
     87           */
     88          
     89          typedef void (*zapProcessFunc_t)(uint8 port, uint8 *pBuf);
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                           Macros
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          
     96          /* ------------------------------------------------------------------------------------------------
     97           *                                           Global Variables
     98           * ------------------------------------------------------------------------------------------------
     99           */
    100          //MHMS:Switches Logical type

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    101          static uint8 zLogicalType=ZG_DEVICETYPE_ROUTER;
   \                     zLogicalType:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for zLogicalType>`
    102          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    103          uint8 zapTaskId;
   \                     zapTaskId:
   \   000000                DS8 1
    104          
    105          // Hook for supporting more than 1 ZNP on different ports.
    106          // An example of use would be to set this to the desired port before invoking AF_DataRequest().

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    107          uint8 zapAppPort;
   \                     zapAppPort:
   \   000000                DS8 1
    108          
    109          // Count of the global ZNP variables that are cached locally on ZAP.
    110          #define ZAP_MON_INFO_CNT  5
    111          
    112          //MHMS:Sending the IEEE address will
    113          // IEEE Address (64-bit Extended Address) of the ZNP device.

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    114          uint8 znpIEEE[8];
   \                     znpIEEE:
   \   000000                DS8 8
    115          
    116          // ZigBee Network Address of the ZNP device.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    117          uint16 znpAddr;
   \                     znpAddr:
   \   000000                DS8 2
    118          // ZigBee Network Address of the parent of the ZNP device.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    119          uint16 znpParent;
   \                     znpParent:
   \   000000                DS8 2
    120          // ZigBee Network PanId.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    121          uint16 znpPanId;
   \                     znpPanId:
   \   000000                DS8 2
    122          // ZNP variable indicating the current device state (from Z-Stack ZDO/ZD_App.c).

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    123          devStates_t devState;
   \                     devState:
   \   000000                DS8 1
    124          
    125          #if SECURE
    126          // ZNP variable read from NV at powerup by the ZGlobals manager - TODO: how to sync value with ZNP?
    127          uint8 zgSecurityMode = ZG_SECURITY_MODE;
    128          #endif
    129          
    130          // Trust center address

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    131          uint16 zgTrustCenterAddr = ZG_TRUSTCENTER_ADDR;
   \                     zgTrustCenterAddr:
   \   000000                DS8 2
    132          
    133          /* ------------------------------------------------------------------------------------------------
    134           *                                           Local Variables
    135           * ------------------------------------------------------------------------------------------------
    136           */
    137          

   \                                 In  segment DATA16_C, align 2, align-sorted
    138          static const zapProcessFunc_t zapProcessFunc[] =
   \                     zapProcessFunc:
   \   000000   00000000.... DC32 0H, zapSysProcessIncoming, 0H, 0H, zapAfProcessIncoming
   \            ....00000000
   \            00000000....
   \            ....        
   \   000014   ............ DC32 zapZdoProcessIncoming, zapSapiProcessIncoming
   \            ....        
   \   00001C   ........0000 DC32 zapUtilProcessIncoming, 0H, 0H
   \            000000000000
    139          {
    140            NULL,
    141          
    142          #if defined (ZAP_SYS_FUNC)
    143            zapSysProcessIncoming,
    144          #else
    145            NULL,
    146          #endif
    147          
    148          #if defined (ZAP_MAC_FUNC)
    149            zapMacProcessIncoming,
    150          #else
    151            NULL,
    152          #endif
    153          
    154          #if defined (ZAP_NWK_FUNC)
    155            zapNwkProcessIncoming,
    156          #else
    157            NULL,
    158          #endif
    159          
    160          #if defined (ZAP_AF_FUNC)
    161            zapAfProcessIncoming,
    162          #else
    163            NULL,
    164          #endif
    165          
    166          #if defined (ZAP_ZDO_FUNC)
    167            zapZdoProcessIncoming,
    168          #else
    169            NULL,
    170          #endif
    171          
    172          #if defined (ZAP_SAPI_FUNC)
    173            zapSapiProcessIncoming,
    174          #else
    175            NULL,
    176          #endif
    177          
    178          #if defined (ZAP_UTIL_FUNC)
    179            zapUtilProcessIncoming,
    180          #else
    181            NULL,
    182          #endif
    183          
    184          #if defined (ZAP_DEBUG_FUNC)
    185            zapDebugProcessIncoming,
    186          #else
    187            NULL,
    188          #endif
    189          
    190          #if defined (ZAP_APP_FUNC)
    191            zapApsProcessIncoming,
    192          #else
    193            NULL,
    194          #endif
    195          };
    196          
    197          #ifdef LCD_SUPPORTED

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    198          static uint16 zapDisAddr;
   \                     zapDisAddr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    199          static uint16 zapDisPanId;
   \                     zapDisPanId:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    200          static uint8  zapDisIEEE[Z_EXTADDR_LEN];
   \                     zapDisIEEE:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    201          static uint8  zapDisState;
   \                     zapDisState:
   \   000000                DS8 1
    202          #endif
    203          
    204          /* ------------------------------------------------------------------------------------------------
    205           *                                           Local Functions
    206           * ------------------------------------------------------------------------------------------------
    207           */
    208          
    209          #if ZAP_ZNP_MT
    210          #include "zap_phy_uart.c"
    211          #if ZAP_APP_MSG
    212          #define MT_APP_FUNC
    213          #include "MT_App.c"
    214          #endif
    215          #endif
    216          
    217          #ifdef LCD_SUPPORTED
    218          static void zapDisInfo(void);
    219          #endif
    220          static void zapMonInfo(void);
    221          #if ZAP_APP_KEYS
    222          static void zapKeys(keyChange_t *msg);
    223          #endif
    224          static void zapMonitor(void);
    225          static void zapSync(void);
    226          static void zapSysEvtMsg(void);
    227          
    228          //MHMS:Adding function from ZGlobals.c to avoid includes
    229          uint8 zgWriteStartupOptions( uint8 action, uint8 bitOptions );
    230          
    231          /*********************************************************************
    232           * @fn          zgWriteStartupOptions
    233           *
    234           * @brief       Writes bits into the ZCD_NV_STARTUP_OPTION NV Item.
    235           *
    236           * @param       action - ZG_STARTUP_SET set bit, ZG_STARTUP_CLEAR to
    237           *               clear bit. The set bit is an OR operation, and the
    238           *               clear bit is an AND ~(bitOptions) operation.
    239           *
    240           * @param       bitOptions - which bits to perform action on:
    241           *                      ZCD_STARTOPT_DEFAULT_CONFIG_STATE
    242           *                      ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    243             
    244           *
    245           * @return      ZSUCCESS if successful
    246           */

   \                                 In  segment CODE, align 2
    247          uint8 zgWriteStartupOptions( uint8 action, uint8 bitOptions )
   \                     zgWriteStartupOptions:
    248          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4B4C         MOV.B   R12, R11
   \   000006   4A4D         MOV.B   R13, R10
    249            uint8 status;
    250            uint8 startupOptions = 0;
   \   000008   C1430000     MOV.B   #0x0, 0(SP)
    251          
    252            status = osal_nv_read( ZCD_NV_STARTUP_OPTION,
    253                          0,
    254                          sizeof( startupOptions ),
    255                          &startupOptions );
   \   00000C   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_9:
   \   000010   ........     CALLA   #osal_nv_read
    256          
    257            if ( status == ZSUCCESS )
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   0C20         JNE     ??zgWriteStartupOptions_0
    258            {
    259              if ( action == ZG_STARTUP_SET )
   \   000018   7B93         CMP.B   #0xff, R11
   \   00001A   0220         JNE     ??zgWriteStartupOptions_1
    260              {
    261                // Set bits
    262                startupOptions |= bitOptions;
   \   00001C   6AD1         BIS.B   @SP, R10
   \   00001E   023C         JMP     ??zgWriteStartupOptions_2
    263              }
    264              else
    265              {
    266                // Clear bits
    267                startupOptions &= (bitOptions ^ 0xFF);
   \                     ??zgWriteStartupOptions_1:
   \   000020   7AE3         XOR.B   #0xff, R10
   \   000022   6AF1         AND.B   @SP, R10
   \                     ??zgWriteStartupOptions_2:
   \   000024   C14A0000     MOV.B   R10, 0(SP)
    268              }
    269          
    270              // Changed?
    271              status = osal_nv_write( ZCD_NV_STARTUP_OPTION,
    272                           0,
    273                           sizeof( startupOptions ),
    274                           &startupOptions );
   \   000028   ........     CALLA   #?Subroutine4
    275            }
   \                     ??CrossCallReturnLabel_10:
   \   00002C   ........     CALLA   #osal_nv_write
    276          
    277            return ( status );
   \                     ??zgWriteStartupOptions_0:
   \   000030   2153         ADD.W   #0x2, SP
   \   000032   1A17         POPM.W  #0x2, R11
   \   000034   1001         RETA
    278          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   0F41         MOV.W   SP, R15
   \   000002   2F52         ADD.W   #0x4, R15
   \   000004   1E43         MOV.W   #0x1, R14
   \   000006   0D43         MOV.W   #0x0, R13
   \   000008   3C400300     MOV.W   #0x3, R12
   \   00000C   1001         RETA
    279          /**************************************************************************************************
    280           * @fn          zapInit
    281           *
    282           * @brief       This function is the application's task initialization.
    283           *
    284           * input parameters
    285           *
    286           * None.
    287           *
    288           * output parameters
    289           *
    290           * None.
    291           *
    292           * @return      None.
    293           **************************************************************************************************
    294           */

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   3E40E803     MOV.W   #0x3e8, R14
   \   000004   3D400010     MOV.W   #0x1000, R13
   \   000008   5C42....     MOV.B   &zapTaskId, R12
   \   00000C   ........     CALLA   #osal_start_timerEx
   \   000010   4C93         CMP.B   #0x0, R12
   \   000012   0624         JEQ     ??zapMonitor_0
   \   000014   3D400010     MOV.W   #0x1000, R13
   \   000018   5C42....     MOV.B   &zapTaskId, R12
   \   00001C   ........     CALLA   #osal_set_event
   \                     ??zapMonitor_0:
   \   000020   1001         RETA

   \                                 In  segment CODE, align 2
    295          void zapInit(uint8 id)
   \                     zapInit:
    296          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    297            zapTaskId = id;
   \   000004   C24C....     MOV.B   R12, &zapTaskId
    298            zapAppPort = ZAP_APP_PORT;
   \   000008   C243....     MOV.B   #0x0, &zapAppPort
    299          
    300            zapPhyInit();
   \   00000C   ........     CALLA   #zapPhyInit
    301          #if ZAP_APP_KEYS
    302            RegisterForKeys(id);
   \   000010   4C4A         MOV.B   R10, R12
   \   000012   ........     CALLA   #RegisterForKeys
    303          #endif
    304          
    305            zapLostSync(ZAP_APP_PORT);
   \   000016   4C43         MOV.B   #0x0, R12
   \   000018   ........     CALLA   #zapLostSync
    306            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_TMR_EVT, ZAP_APP_TMR_DLY))
   \   00001C   ........     CALLA   #?Subroutine1
    307            {
    308              (void)osal_set_event(zapTaskId, ZAP_APP_TMR_EVT);
    309            }
    310          
    311          #if !ZAP_PHY_RESET_ZNP
    312            uint8 *pBuf;
    313            if ((pBuf = zap_msg_allocate(0, (uint8)MT_RPC_SYS_UTIL | (uint8)MT_RPC_CMD_AREQ,
    314                                            (uint8)MT_UTIL_SYNC_REQ)) != NULL)
    315            {
    316              zapPhySend(zapAppPort, pBuf);
    317              zap_msg_deallocate(&pBuf);
    318            }
    319          #endif
    320          
    321          #if ZAP_ZNP_MT
    322            zapPhyUartInit();
    323          #endif
    324          }
   \                     ??CrossCallReturnLabel_5:
   \   000020   3A41         POP.W   R10
   \   000022   1001         RETA
    325          
    326          /**************************************************************************************************
    327           * @fn          zapEvt
    328           *
    329           * @brief       This function is called to process the OSAL events for the task.
    330           *
    331           * input parameters
    332           *
    333           * @param       id - OSAL task Id.
    334           * @param       evts - OSAL events bit mask of pending events.
    335           *
    336           * output parameters
    337           *
    338           * None.
    339           *
    340           * @return      evts - OSAL events bit mask of unprocessed events.
    341           **************************************************************************************************
    342           */

   \                                 In  segment CODE, align 2
    343          uint16 zapEvt(uint8 id, uint16 evts)
   \                     zapEvt:
    344          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4D         MOV.W   R13, R10
    345            uint16 mask = 0;
    346            (void)id;
    347          
    348            if (evts & SYS_EVENT_MSG)
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1C34         JGE     ??zapEvt_4
    349            {
    350              mask = SYS_EVENT_MSG;
   \   000008   3B400080     MOV.W   #0x8000, R11
    351              zapSysEvtMsg();
   \   00000C   093C         JMP     ??zapEvt_5
   \                     ??zapEvt_0:
   \   00000E   1D4C0200     MOV.W   0x2(R12), R13
   \   000012   5C480100     MOV.B   0x1(R8), R12
   \   000016   ........     CALLA   #zapProcessIncoming
   \                     ??zapEvt_1:
   \   00001A   0C48         MOV.W   R8, R12
   \   00001C   ........     CALLA   #osal_msg_deallocate
   \                     ??zapEvt_5:
   \   000020   5C42....     MOV.B   &zapTaskId, R12
   \   000024   ........     CALLA   #osal_msg_receive
   \   000028   084C         MOV.W   R12, R8
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   3224         JEQ     ??zapEvt_6
   \   00002E   6E4C         MOV.B   @R12, R14
   \   000030   5E83         SUB.B   #0x1, R14
   \   000032   ED27         JEQ     ??zapEvt_0
   \   000034   7E80BF00     SUB.B   #0xbf, R14
   \   000038   F023         JNE     ??zapEvt_1
   \   00003A   ........     CALLA   #zapKeys
   \   00003E   ED3F         JMP     ??zapEvt_1
    352            }
    353            else if (evts & (ZAP_PHY_SPI_EVT | ZAP_PHY_UART_EVT))
   \                     ??zapEvt_4:
   \   000040   0B4D         MOV.W   R13, R11
   \   000042   3BF00060     AND.W   #0x6000, R11
   \   000046   0424         JEQ     ??zapEvt_7
    354            {
    355              mask = evts & (ZAP_PHY_SPI_EVT | ZAP_PHY_UART_EVT);
    356              zapPhyExec(mask);
   \   000048   0C4B         MOV.W   R11, R12
   \   00004A   ........     CALLA   #zapPhyExec
   \   00004E   213C         JMP     ??zapEvt_6
    357            }
    358            else if (evts & ZAP_APP_TMR_EVT)
   \                     ??zapEvt_7:
   \   000050   3DB00010     BIT.W   #0x1000, R13
   \   000054   0528         JNC     ??zapEvt_8
    359            {
    360              mask = ZAP_APP_TMR_EVT;
   \   000056   3B400010     MOV.W   #0x1000, R11
    361              zapMonitor();
   \   00005A   ........     CALLA   #zapMonitor
   \   00005E   193C         JMP     ??zapEvt_6
    362            }
    363            else if (evts & ZAP_APP_SYNC_EVT)
   \                     ??zapEvt_8:
   \   000060   3DB00008     BIT.W   #0x800, R13
   \   000064   0528         JNC     ??zapEvt_9
    364            {
    365              mask = ZAP_APP_SYNC_EVT;
   \   000066   3B400008     MOV.W   #0x800, R11
    366              zapSync();
   \   00006A   ........     CALLA   #zapSync
   \   00006E   113C         JMP     ??zapEvt_6
    367            }
    368            else if (evts & ZAP_APP_ZDO_STATE_CHANGE_EVT)
   \                     ??zapEvt_9:
   \   000070   3DB00004     BIT.W   #0x400, R13
   \   000074   0D28         JNC     ??zapEvt_10
    369            {
    370              mask = ZAP_APP_ZDO_STATE_CHANGE_EVT;
   \   000076   3B400004     MOV.W   #0x400, R11
    371          
    372          #ifdef LCD_SUPPORTED
    373              // Loop to get all of the cached, global ZNP variables for the sake of a timely LCD update.
    374              for (id = 0; id <= ZAP_MON_INFO_CNT; id++)
   \   00007A   78400600     MOV.B   #0x6, R8
    375              {
    376                zapMonInfo();
   \                     ??zapEvt_2:
   \   00007E   ........     CALLA   #zapMonInfo
    377              }
   \   000082   7853         ADD.B   #0xff, R8
   \   000084   FC23         JNE     ??zapEvt_2
    378          #else
    379              // Otherwise, just get what is needed for the ZDO state change update.
    380              zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
    381          #endif
    382          
    383              ZDO_UpdateNwkStatus(devState);
   \   000086   5C42....     MOV.B   &devState, R12
   \   00008A   ........     CALLA   #ZDO_UpdateNwkStatus
   \   00008E   013C         JMP     ??zapEvt_6
    384            }
    385            else
    386            {
    387              mask = evts;  // Discard unknown events - should never happen.
   \                     ??zapEvt_10:
   \   000090   0B4D         MOV.W   R13, R11
    388            }
    389          
    390            return (evts ^ mask);  // Return unprocessed events.
   \                     ??zapEvt_6:
   \   000092   0AEB         XOR.W   R11, R10
   \   000094   0C4A         MOV.W   R10, R12
   \   000096   3817         POPM.W  #0x4, R11
   \   000098   1001         RETA
    391          }
    392          
    393          /**************************************************************************************************
    394           * @fn          zapGotSync
    395           *
    396           * @brief       This function is invoked upon receipt of MT_SYS_RESET_IND or MT_UTIL_SYNC_REQ
    397           *              and would indicate that sync is (re-)gained with the ZNP.
    398           *
    399           * input parameters
    400           *
    401           * @param       port - Port Id corresponding to the ZNP that got sync.
    402           *
    403           * output parameters
    404           *
    405           * None.
    406           *
    407           * @return      None.
    408           **************************************************************************************************
    409           */

   \                                 In  segment CODE, align 2
    410          void zapGotSync(uint8 port)
   \                     zapGotSync:
    411          {
    412            zapPhySync(port);
   \   000000   ........     CALLA   #zapPhySync
    413          
    414            // Especially for UART transport, allow time for multiple got syncs before acting on it.
    415            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_SYNC_EVT, ZAP_APP_SYNC_DLY))
   \   000004   3E406400     MOV.W   #0x64, R14
   \   000008   3D400008     MOV.W   #0x800, R13
   \   00000C   5C42....     MOV.B   &zapTaskId, R12
   \   000010   ........     CALLA   #osal_start_timerEx
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   0624         JEQ     ??zapGotSync_0
    416            {
    417              (void)osal_set_event(zapTaskId, ZAP_APP_SYNC_EVT);
   \   000018   3D400008     MOV.W   #0x800, R13
   \   00001C   5C42....     MOV.B   &zapTaskId, R12
   \   000020   ........     CALLA   #osal_set_event
    418            }
    419          }
   \                     ??zapGotSync_0:
   \   000024   1001         RETA
    420          
    421          /**************************************************************************************************
    422           * @fn          zapLostSync
    423           *
    424           * @brief       This function is invoked by the PHY drivers when sync is lost with the ZNP.
    425           *
    426           * input parameters
    427           *
    428           * @param       port - Port Id corresponding to the ZNP that lost sync.
    429           *
    430           * output parameters
    431           *
    432           * None.
    433           *
    434           * @return      None.
    435           **************************************************************************************************
    436           */

   \                                 In  segment CODE, align 2
    437          void zapLostSync(uint8 port)
   \                     zapLostSync:
    438          {
    439            devState = DEV_STATE_INVALID;
   \   000000   F240FC00.... MOV.B   #0xfc, &devState
    440            znpAddr = znpParent = INVALID_NODE_ADDR;
   \   000006   B240FEFF.... MOV.W   #0xfffe, &znpParent
   \   00000C   B240FEFF.... MOV.W   #0xfffe, &znpAddr
    441            znpPanId = 0xFFFF;
   \   000012   B243....     MOV.W   #0xffff, &znpPanId
    442          }
   \   000016   1001         RETA
    443          
    444          /**************************************************************************************************
    445           * @fn          zapProcessIncoming
    446           *
    447           * @brief       This function is called by zapSysEvtMsg() to process an incoming message from ZNP.
    448           *
    449           * input parameters
    450           *
    451           * @param       port - Port Id corresponding to the ZNP that sent the message.
    452           * @param       pBuf - Pointer to event message.
    453           *
    454           * output parameters
    455           *
    456           * None.
    457           *
    458           * @return      None.
    459           **************************************************************************************************
    460           */

   \                                 In  segment CODE, align 2
    461          void zapProcessIncoming(uint8 port, uint8 *pBuf)
   \                     zapProcessIncoming:
    462          {
   \   000000   0A12         PUSH.W  R10
    463            if ((pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK) < MT_RPC_SYS_MAX)
   \   000002   5F4D0100     MOV.B   0x1(R13), R15
   \   000006   4E4F         MOV.B   R15, R14
   \   000008   7EF01F00     AND.B   #0x1f, R14
   \   00000C   7E900B00     CMP.B   #0xb, R14
   \   000010   0D2C         JC      ??zapProcessIncoming_0
    464            {
    465              zapProcessFunc_t func;
    466          
    467              if (NULL != (func = zapProcessFunc[pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK]))
   \   000012   3FF01F00     AND.W   #0x1f, R15
   \   000016   5F06         RLAM.W  #0x2, R15
   \   000018   1E4F....     MOV.W   zapProcessFunc(R15), R14
   \   00001C   1F4F....     MOV.W   zapProcessFunc + 2(R15), R15
   \   000020   0A4E         MOV.W   R14, R10
   \   000022   0ADF         BIS.W   R15, R10
   \   000024   0A93         CMP.W   #0x0, R10
   \   000026   0224         JEQ     ??zapProcessIncoming_0
    468              {
    469                func(port, pBuf);
   \   000028   ........     CALLA   #?IndCallR15
    470              }
    471            }
    472          
    473          #if ZAP_ZNP_MT
    474          #if ZAP_APP_MSG
    475            if ((MT_RPC_SYS_APP == (pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK)) &&
    476                    (MT_APP_MSG ==  pBuf[MT_RPC_POS_CMD1]))
    477            {
    478              MT_AppMsg(pBuf);
    479            }
    480            else
    481          #endif
    482            {
    483              MT_BuildAndSendZToolResponse(pBuf[MT_RPC_POS_CMD0], pBuf[MT_RPC_POS_CMD1],
    484                                           pBuf[MT_RPC_POS_LEN],  pBuf+MT_RPC_POS_DAT0);
    485            }
    486          #endif
    487          }
   \                     ??zapProcessIncoming_0:
   \   00002C   3A41         POP.W   R10
   \   00002E   1001         RETA
    488          
    489          /**************************************************************************************************
    490           * @fn          zap_msg_allocate
    491           *
    492           * @brief       This function allocates and pre-fills a dynamic RPC message buffer.
    493           *
    494           * input parameters
    495           *
    496           * @param       len - length of the data to send via RPC (i.e. not including RPC overhead.)
    497           * @param       cmd0 - a valid logical OR of the mtRpcCmdType_t & mtRpcSysType_t.
    498           * @param       cmd1 - a valid command for the mtRpcSysType_t.
    499           *
    500           * output parameters
    501           *
    502           * None.
    503           *
    504           * @return      NULL on failure to allocate all memory necessary.
    505           *              A pointer to the data area (size 'len') of a valid dynamic memory buffer on success.
    506           **************************************************************************************************
    507           */

   \                                 In  segment CODE, align 2
    508          uint8 *zap_msg_allocate(uint8 len, uint8 cmd0, uint8 cmd1)
   \                     zap_msg_allocate:
    509          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   484E         MOV.B   R14, R8
    510            // An SREQ buffer must be big enough to accept an SRSP up to the max allowable size.
    511            const uint8 sz = (MT_RPC_CMD_SREQ == (cmd0 & MT_RPC_CMD_TYPE_MASK)) ? MT_RPC_DATA_MAX : len;
   \   000008   4E4D         MOV.B   R13, R14
   \   00000A   7EF0E000     AND.B   #0xe0, R14
   \   00000E   7E902000     CMP.B   #0x20, R14
   \   000012   0320         JNE     ??zap_msg_allocate_0
   \   000014   7C40FA00     MOV.B   #0xfa, R12
   \   000018   013C         JMP     ??zap_msg_allocate_1
   \                     ??zap_msg_allocate_0:
   \   00001A   4C4A         MOV.B   R10, R12
    512            // Add space for the RPC frame header and UART transport SOP and FCS.
    513            uint8 *pBuf = (uint8 *)osal_mem_alloc(sz + MT_RPC_FRAME_HDR_SZ + 2);
   \                     ??zap_msg_allocate_1:
   \   00001C   3C500500     ADD.W   #0x5, R12
   \   000020   ........     CALLA   #osal_mem_alloc
    514          
    515            if (NULL != pBuf)
   \   000024   0C93         CMP.W   #0x0, R12
   \   000026   1424         JEQ     ??zap_msg_allocate_2
    516            {
    517              // Pre-seed the SOP for UART transport.
    518              *pBuf++ = MT_UART_SOF;
   \   000028   FC40FE000000 MOV.B   #0xfe, 0(R12)
   \   00002E   1C53         ADD.W   #0x1, R12
    519              *pBuf++ = len;
   \   000030   CC4A0000     MOV.B   R10, 0(R12)
   \   000034   1C53         ADD.W   #0x1, R12
    520              *pBuf++ = cmd0;
   \   000036   CC4B0000     MOV.B   R11, 0(R12)
   \   00003A   1C53         ADD.W   #0x1, R12
    521              *pBuf++ = cmd1;
   \   00003C   CC480000     MOV.B   R8, 0(R12)
   \   000040   1C53         ADD.W   #0x1, R12
    522              #if (3 != MT_RPC_FRAME_HDR_SZ)
    523              #error Need to port RPC frame header changes here.
    524              #endif
    525              // Pre-seed the FCS for UART transport.
    526              *(pBuf + len) = len ^ cmd0 ^ cmd1;
   \   000042   4E4A         MOV.B   R10, R14
   \   000044   4EEB         XOR.B   R11, R14
   \   000046   4EE8         XOR.B   R8, R14
   \   000048   0F4C         MOV.W   R12, R15
   \   00004A   0F5A         ADD.W   R10, R15
   \   00004C   CF4E0000     MOV.B   R14, 0(R15)
    527            }
    528          
    529            return pBuf;
   \                     ??zap_msg_allocate_2:
   \   000050   3817         POPM.W  #0x4, R11
   \   000052   1001         RETA
    530          }
    531          
    532          /**************************************************************************************************
    533           * @fn          zap_msg_deallocate
    534           *
    535           * @brief       This function deallocates an RPC message buffer created with zap_msg_allocate().
    536           *
    537           * input parameters
    538           *
    539           * @param       ppBuf - A pointer to the buffer pointer returned by zap_msg_allocate().
    540           *
    541           * output parameters
    542           *
    543           * None.
    544           *
    545           * @return      None.
    546           **************************************************************************************************
    547           */

   \                                 In  segment CODE, align 2
    548          void zap_msg_deallocate(uint8 **ppBuf)
   \                     zap_msg_deallocate:
    549          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    550            uint8 *pBuf;
    551          
    552            HAL_ASSERT(ppBuf);
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0220         JNE     ??zap_msg_deallocate_0
   \   000008   ........     CALLA   #halAssertHandler
    553          
    554            if (NULL == *ppBuf)
   \                     ??zap_msg_deallocate_0:
   \   00000C   2C4A         MOV.W   @R10, R12
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   0524         JEQ     ??zap_msg_deallocate_1
    555            {
    556              return;
    557            }
    558          
    559            pBuf = *ppBuf - (MT_RPC_FRAME_HDR_SZ + 1);
   \   000012   2C82         SUB.W   #0x4, R12
    560            *ppBuf = NULL;
   \   000014   8A430000     MOV.W   #0x0, 0(R10)
    561            osal_mem_free((void *)pBuf);
   \   000018   ........     CALLA   #osal_mem_free
    562          }
   \                     ??zap_msg_deallocate_1:
   \   00001C   3A41         POP.W   R10
   \   00001E   1001         RETA
    563          
    564          #ifdef LCD_SUPPORTED
    565          /**************************************************************************************************
    566           * @fn          zapDisInfo
    567           *
    568           * @brief       This displays the IEEE (MSB to LSB) and Network State & Address on the LCD whenever
    569           *              a change in the value is detected.
    570           *
    571           * input parameters
    572           *
    573           * None.
    574           *
    575           * output parameters
    576           *
    577           * None.
    578           *
    579           * @return      None.
    580           **************************************************************************************************
    581           */

   \                                 In  segment CODE, align 2
    582          static void zapDisInfo(void)
   \                     zapDisInfo:
    583          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801200     SUB.W   #0x12, SP
    584            uint8 i;
    585            uint8 *xad;
    586            uint8 lcd_buf[Z_EXTADDR_LEN*2+1];
    587          
    588            if (!osal_memcmp(zapDisIEEE, znpIEEE, Z_EXTADDR_LEN))
   \   000006   7A401000     MOV.B   #0x10, R10
   \   00000A   3E42         MOV.W   #0x8, R14
   \   00000C   3D40....     MOV.W   #znpIEEE, R13
   \   000010   3C40....     MOV.W   #zapDisIEEE, R12
   \   000014   ........     CALLA   #osal_memcmp
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   1E20         JNE     ??zapDisInfo_6
    589            {
    590              (void)osal_memcpy(zapDisIEEE, znpIEEE, Z_EXTADDR_LEN);
   \   00001C   3E42         MOV.W   #0x8, R14
   \   00001E   3D40....     MOV.W   #znpIEEE, R13
   \   000022   3C40....     MOV.W   #zapDisIEEE, R12
   \   000026   ........     CALLA   #osal_memcpy
    591              xad = znpIEEE + Z_EXTADDR_LEN - 1;
   \   00002A   3D40....     MOV.W   #znpIEEE + 7, R13
    592          
    593              for (i = 0; i < Z_EXTADDR_LEN*2; xad--)
   \   00002E   4843         MOV.B   #0x0, R8
   \   000030   0C41         MOV.W   SP, R12
   \   000032   0C53         ADD.W   #0x0, R12
    594              {
    595                uint8 ch;
    596                ch = (*xad >> 4) & 0x0F;
   \                     ??zapDisInfo_0:
   \   000034   6B4D         MOV.B   @R13, R11
   \   000036                RPT     #0x4
   \   000036   43194B10     RRUX.B  R11
    597                lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \   00003A   ........     CALLA   #?Subroutine3
    598                ch = *xad & 0x0F;
   \                     ??CrossCallReturnLabel_7:
   \   00003E   6B4D         MOV.B   @R13, R11
   \   000040   7BF00F00     AND.B   #0xf, R11
    599                lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \   000044   ........     CALLA   #?Subroutine3
    600              }
   \                     ??CrossCallReturnLabel_8:
   \   000048   3D53         ADD.W   #0xffff, R13
   \   00004A   489A         CMP.B   R10, R8
   \   00004C   F32B         JNC     ??zapDisInfo_0
    601              lcd_buf[Z_EXTADDR_LEN*2] = '\0';
   \   00004E   C1431000     MOV.B   #0x0, 0x10(SP)
    602              HalLcdWriteString((char *)lcd_buf, HAL_LCD_LINE_1);
   \   000052   5D43         MOV.B   #0x1, R13
   \   000054   ........     CALLA   #HalLcdWriteString
    603            }
    604          
    605            if ((zapDisState != devState) || (zapDisAddr != znpAddr))
   \                     ??zapDisInfo_6:
   \   000058   1D42....     MOV.W   &znpAddr, R13
   \   00005C   5E42....     MOV.B   &devState, R14
   \   000060   C29E....     CMP.B   R14, &zapDisState
   \   000064   0320         JNE     ??zapDisInfo_7
   \   000066   829D....     CMP.W   R13, &zapDisAddr
   \   00006A   2124         JEQ     ??zapDisInfo_8
    606            {
    607              zapDisState = devState;
   \                     ??zapDisInfo_7:
   \   00006C   C24E....     MOV.B   R14, &zapDisState
    608              zapDisAddr = znpAddr;
   \   000070   824D....     MOV.W   R13, &zapDisAddr
    609          
    610              switch (devState)
   \   000074   7E800600     SUB.B   #0x6, R14
   \   000078   0524         JEQ     ??zapDisInfo_9
   \   00007A   5E83         SUB.B   #0x1, R14
   \   00007C   0824         JEQ     ??zapDisInfo_10
   \   00007E   6E83         SUB.B   #0x2, R14
   \   000080   0B24         JEQ     ??zapDisInfo_11
   \   000082   0F3C         JMP     ??zapDisInfo_12
    611              {
    612              case DEV_END_DEVICE:
    613                HalLcdWriteStringValue("End Device", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_9:
   \   000084   6F43         MOV.B   #0x2, R15
   \   000086   4E4A         MOV.B   R10, R14
   \   000088   3C40....     MOV.W   #`?<Constant "End Device">`, R12
   \   00008C   0E3C         JMP     ??zapDisInfo_1
    614                break;
    615          
    616              case DEV_ROUTER:
    617                HalLcdWriteStringValue("ZigBee Rtr", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_10:
   \   00008E   6F43         MOV.B   #0x2, R15
   \   000090   4E4A         MOV.B   R10, R14
   \   000092   3C40....     MOV.W   #`?<Constant "ZigBee Rtr">`, R12
   \   000096   093C         JMP     ??zapDisInfo_1
    618                break;
    619          
    620              case DEV_ZB_COORD:
    621                HalLcdWriteStringValue("ZigBee Coord", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_11:
   \   000098   6F43         MOV.B   #0x2, R15
   \   00009A   4E4A         MOV.B   R10, R14
   \   00009C   3C40....     MOV.W   #`?<Constant "ZigBee Coord">`, R12
   \   0000A0   043C         JMP     ??zapDisInfo_1
    622                break;
    623          
    624              default:
    625                HalLcdWriteStringValue("Other Inval", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_12:
   \   0000A2   6F43         MOV.B   #0x2, R15
   \   0000A4   4E4A         MOV.B   R10, R14
   \   0000A6   3C40....     MOV.W   #`?<Constant "Other Inval">`, R12
   \                     ??zapDisInfo_1:
   \   0000AA   ........     CALLA   #HalLcdWriteStringValue
    626                break;
    627              }
    628            }
    629          
    630            if (zapDisPanId != znpPanId)
   \                     ??zapDisInfo_8:
   \   0000AE   1D42....     MOV.W   &znpPanId, R13
   \   0000B2   829D....     CMP.W   R13, &zapDisPanId
   \   0000B6   0924         JEQ     ??zapDisInfo_13
    631            {
    632              zapDisPanId = znpPanId;
   \   0000B8   824D....     MOV.W   R13, &zapDisPanId
    633              HalLcdWriteStringValue("PanId 0x", znpPanId, 16, HAL_LCD_LINE_3);
   \   0000BC   7F400300     MOV.B   #0x3, R15
   \   0000C0   4E4A         MOV.B   R10, R14
   \   0000C2   3C40....     MOV.W   #`?<Constant "PanId 0x">`, R12
   \   0000C6   ........     CALLA   #HalLcdWriteStringValue
    634            }
    635          }
   \                     ??zapDisInfo_13:
   \   0000CA   31501200     ADD.W   #0x12, SP
   \   0000CE   3817         POPM.W  #0x4, R11
   \   0000D0   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   4F48         MOV.B   R8, R15
   \   000002   5853         ADD.B   #0x1, R8
   \   000004   7B900A00     CMP.B   #0xa, R11
   \   000008   0328         JNC     ??zapDisInfo_2
   \   00000A   7E403700     MOV.B   #0x37, R14
   \   00000E   023C         JMP     ??zapDisInfo_3
   \                     ??zapDisInfo_2:
   \   000010   7E403000     MOV.B   #0x30, R14
   \                     ??zapDisInfo_3:
   \   000014   4B5E         ADD.B   R14, R11
   \   000016   0E4C         MOV.W   R12, R14
   \   000018   0E5F         ADD.W   R15, R14
   \   00001A   CE4B0000     MOV.B   R11, 0(R14)
   \   00001E   1001         RETA
    636          #endif
    637          
    638          /**************************************************************************************************
    639           * @fn          zapMonInfo
    640           *
    641           * @brief       This function is invoked by zapMonitor during steady state in order to maintain
    642           *              the local copies of ZNP-side global variables.
    643           *
    644           * input parameters
    645           *
    646           * None.
    647           *
    648           * output parameters
    649           *
    650           * None.
    651           *
    652           * @return      None.
    653           **************************************************************************************************
    654           */

   \                                 In  segment CODE, align 2
    655          static void zapMonInfo(void)
   \                     zapMonInfo:
    656          {
    657            static uint8 getInfoIdx;
    658          
    659            switch (getInfoIdx++)
   \   000000   5E42....     MOV.B   &??getInfoIdx, R14
   \   000004   4F4E         MOV.B   R14, R15
   \   000006   5F53         ADD.B   #0x1, R15
   \   000008   C24F....     MOV.B   R15, &??getInfoIdx
   \   00000C   4E83         SUB.B   #0x0, R14
   \   00000E   0924         JEQ     ??zapMonInfo_0
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   0C24         JEQ     ??zapMonInfo_1
   \   000014   5E83         SUB.B   #0x1, R14
   \   000016   0F24         JEQ     ??zapMonInfo_2
   \   000018   5E83         SUB.B   #0x1, R14
   \   00001A   1224         JEQ     ??zapMonInfo_3
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   1624         JEQ     ??zapMonInfo_4
   \   000020   1B3C         JMP     ??zapMonInfo_5
    660            {
    661            case 0:
    662              zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapMonInfo_0:
   \   000022   3D40....     MOV.W   #devState, R13
   \   000026   4C43         MOV.B   #0x0, R12
   \   000028   ........     BRA     #zb_GetDeviceInfo
    663              break;
    664            case 1:
    665              zb_GetDeviceInfo(ZB_INFO_IEEE_ADDR, &znpIEEE);
   \                     ??zapMonInfo_1:
   \   00002C   3D40....     MOV.W   #znpIEEE, R13
   \   000030   5C43         MOV.B   #0x1, R12
   \   000032   ........     BRA     #zb_GetDeviceInfo
    666              break;
    667            case 2:
    668              zb_GetDeviceInfo(ZB_INFO_SHORT_ADDR, &znpAddr);
   \                     ??zapMonInfo_2:
   \   000036   3D40....     MOV.W   #znpAddr, R13
   \   00003A   6C43         MOV.B   #0x2, R12
   \   00003C   ........     BRA     #zb_GetDeviceInfo
    669              break;
    670            case 3:
    671              zb_GetDeviceInfo(ZB_INFO_PARENT_SHORT_ADDR, &znpParent);
   \                     ??zapMonInfo_3:
   \   000040   3D40....     MOV.W   #znpParent, R13
   \   000044   7C400300     MOV.B   #0x3, R12
   \   000048   ........     BRA     #zb_GetDeviceInfo
    672              break;
    673            case 4:
    674              zb_GetDeviceInfo(ZB_INFO_PAN_ID, &znpPanId);
   \                     ??zapMonInfo_4:
   \   00004C   3D40....     MOV.W   #znpPanId, R13
   \   000050   7C400600     MOV.B   #0x6, R12
   \   000054   ........     BRA     #zb_GetDeviceInfo
    675              break;
    676            // Update ZAP_MON_INFO_CNT whenever another case is added.
    677            default:
    678          #ifdef LCD_SUPPORTED
    679              zapDisInfo();
   \                     ??zapMonInfo_5:
   \   000058   ........     CALLA   #zapDisInfo
    680          #endif
    681              getInfoIdx = 0;
   \   00005C   C243....     MOV.B   #0x0, &??getInfoIdx
    682              break;
    683            }
    684          }
   \   000060   1001         RETA

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??getInfoIdx:
   \   000000                DS8 1
    685          
    686          #if ZAP_APP_KEYS
    687          /**************************************************************************************************
    688           * @fn          zapKeys
    689           *
    690           * @brief       This function is called by zapSysEvtMsg() to process a key(s) event.
    691           *
    692           * input parameters
    693           *
    694           * None.
    695           *
    696           * output parameters
    697           *
    698           * None.
    699           *
    700           * @return      None.
    701          * MHMS:SW1 and SW2 here are currently set to change the logical type of the Zigbee node.
    702          *
    703           **************************************************************************************************
    704           */

   \                                 In  segment CODE, align 2
    705          static void zapKeys(keyChange_t *msg)
   \                     zapKeys:
    706          {
   \   000000   3B15         PUSHM.W #0x4, R11
    707            const uint8 keys = msg->keys;
   \   000002   5A4C0300     MOV.B   0x3(R12), R10
    708          
    709            if (msg->state)  // Shift key.
   \   000006   CC930200     CMP.B   #0x0, 0x2(R12)
   \   00000A   1E20         JNE     ??zapKeys_0
    710            {
    711              if (keys & HAL_KEY_SW_1)
    712              {
    713              }
    714              if (keys & HAL_KEY_SW_2)
    715              {
    716              }
    717              if (keys & HAL_KEY_SW_3)
    718              {
    719              }
    720              if (keys & HAL_KEY_SW_4)
    721              {
    722              }
    723            }
    724            else
    725            {
    726              if (keys & HAL_KEY_SW_1)
   \   00000C   7B401000     MOV.B   #0x10, R11
   \   000010   78400700     MOV.B   #0x7, R8
   \   000014   5AB3         BIT.B   #0x1, R10
   \   000016   0B28         JNC     ??zapKeys_1
    727              {
    728                //MHMS:SW1 type change to coordinator
    729                if(zap_set_logicalType(ZG_DEVICETYPE_COORDINATOR)){
   \   000018   4C43         MOV.B   #0x0, R12
   \   00001A   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_11:
   \   00001E   0324         JEQ     ??zapKeys_2
    730                HalLcdWriteStringValue("Should be Coord.",0, 16, HAL_LCD_LINE_7);
   \   000020   3C40....     MOV.W   #`?<Constant "Should be Coord.">`, R12
   \   000024   023C         JMP     ??zapKeys_3
    731                }
    732                else{
    733                HalLcdWriteStringValue("Problem Writing",0, 16, HAL_LCD_LINE_7);
   \                     ??zapKeys_2:
   \   000026   3C40....     MOV.W   #`?<Constant "Problem Writing">`, R12
   \                     ??zapKeys_3:
   \   00002A   ........     CALLA   #HalLcdWriteStringValue
    734                }
    735              }
    736              if (keys & HAL_KEY_SW_2)
   \                     ??zapKeys_1:
   \   00002E   6AB3         BIT.B   #0x2, R10
   \   000030   0B28         JNC     ??zapKeys_0
    737              {
    738               //MHMS: Try and implement ZdoStateChange to Router
    739               if(zap_set_logicalType(ZG_DEVICETYPE_ROUTER)){
   \   000032   5C43         MOV.B   #0x1, R12
   \   000034   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_12:
   \   000038   0324         JEQ     ??zapKeys_4
    740                HalLcdWriteStringValue("Should be Router",0, 16, HAL_LCD_LINE_7);
   \   00003A   3C40....     MOV.W   #`?<Constant "Should be Router">`, R12
   \   00003E   023C         JMP     ??zapKeys_5
    741                }
    742                else{
    743                HalLcdWriteStringValue("Problem Writing",0, 16, HAL_LCD_LINE_7);
   \                     ??zapKeys_4:
   \   000040   3C40....     MOV.W   #`?<Constant "Problem Writing">`, R12
   \                     ??zapKeys_5:
   \   000044   ........     CALLA   #HalLcdWriteStringValue
    744                }
    745              }
    746              if (keys & HAL_KEY_SW_3)
    747              {
    748              }
    749              if (keys & HAL_KEY_SW_4)
    750              {
    751              }
    752            }
    753          }
   \                     ??zapKeys_0:
   \   000048   3817         POPM.W  #0x4, R11
   \   00004A   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   ........     CALLA   #zap_set_logicalType
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   4F48         MOV.B   R8, R15
   \   000008   4E4B         MOV.B   R11, R14
   \   00000A   0D43         MOV.W   #0x0, R13
   \   00000C   1001         RETA
    754          #endif
    755          
    756          /**************************************************************************************************
    757           * @fn          zapMonitor
    758           *
    759           * @brief       This function is called by OSAL timer or event to monitor the ZNP for all.
    760           *
    761           * input parameters
    762           *
    763           * None.
    764           *
    765           * output parameters
    766           *
    767           * None.
    768           *
    769           * @return      None.
    770           **************************************************************************************************
    771           */

   \                                 In  segment CODE, align 2, keep-with-next
    772          static void zapMonitor(void)
   \                     zapMonitor:
    773          {
    774            /* If the ZNP has not already reported by the first monitor run, only the ZAP has reset and not
    775             * the ZNP; or the ZAP/ZNP sync has been lost.
    776             */
    777            if (DEV_STATE_INVALID == devState)
   \   000000   5E42....     MOV.B   &devState, R14
   \   000004   7E90FC00     CMP.B   #0xfc, R14
   \   000008   0A20         JNE     ??zapMonitor_1
    778            {
    779          #if ZAP_APP_LED
    780              HalLedSet (HAL_LED_2, HAL_LED_MODE_OFF);
    781          #endif
    782              devState = DEV_STATE_SYNC_LOST;
   \   00000A   F240FD00.... MOV.B   #0xfd, &devState
    783              zapUtilReq(MT_UTIL_SYNC_REQ, NULL, NULL);
   \   000010   0E43         MOV.W   #0x0, R14
   \   000012   0D43         MOV.W   #0x0, R13
   \   000014   7C40E000     MOV.B   #0xe0, R12
   \   000018   ........     CALLA   #zapUtilReq
   \   00001C   1C3C         JMP     ??zapMonitor_2
    784            }
    785            else if (DEV_STATE_SYNC_LOST == devState)
   \                     ??zapMonitor_1:
   \   00001E   7E90FD00     CMP.B   #0xfd, R14
   \   000022   0720         JNE     ??zapMonitor_3
    786            {
    787              devState = DEV_STATE_ZNP_LOST;
   \   000024   F240FE00.... MOV.B   #0xfe, &devState
    788              znpSystemReset(ZNP_RESET_SOFT);
   \   00002A   5C43         MOV.B   #0x1, R12
   \   00002C   ........     CALLA   #znpSystemReset
   \   000030   123C         JMP     ??zapMonitor_2
    789            }
    790            else if (DEV_STATE_ZNP_LOST == devState)
   \                     ??zapMonitor_3:
   \   000032   7E90FE00     CMP.B   #0xfe, R14
   \   000036   0520         JNE     ??zapMonitor_4
    791            {
    792              devState = DEV_STATE_ZAP_LOST;
   \   000038   F243....     MOV.B   #0xff, &devState
    793              zapPhyReset(zapAppPort);
   \   00003C   ........     CALLA   #?Subroutine0
    794            }
   \                     ??CrossCallReturnLabel_0:
   \   000040   0A3C         JMP     ??zapMonitor_2
    795            else if (DEV_STATE_ZAP_LOST == devState)
   \                     ??zapMonitor_4:
   \   000042   7E93         CMP.B   #0xff, R14
   \   000044   0620         JNE     ??zapMonitor_5
    796            {
    797              HalReset();
   \   000046   32C2         dint
   \   000048   0343         nop
   \   00004A   B24004A52001 MOV.W   #0xa504, &0x120
   \   000050   023C         JMP     ??zapMonitor_2
    798            }
    799            else
    800            {
    801          #if ZAP_APP_LED
    802              HalLedSet (HAL_LED_2, HAL_LED_MODE_ON);
    803          #endif
    804              zapMonInfo();
   \                     ??zapMonitor_5:
   \   000052   ........     CALLA   #zapMonInfo
    805            }
    806          
    807            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_TMR_EVT, ZAP_APP_TMR_DLY))
   \                     ??zapMonitor_2:
   \   000056                REQUIRE ?Subroutine1
   \   000056                REQUIRE _A_PMMCTL0_L
   \   000056                // Fall through to label ?Subroutine1
    808            {
    809              (void)osal_set_event(zapTaskId, ZAP_APP_TMR_EVT);
    810            }
    811          
    812          #if ZAP_APP_LED
    813            HalLedSet (HAL_LED_4, HAL_LED_MODE_TOGGLE);
    814          #endif
    815          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   5C42....     MOV.B   &zapAppPort, R12
   \   000004   ........     BRA     #zapPhyReset
    816          
    817          /**************************************************************************************************
    818           * @fn          zapSync
    819           *
    820           * @brief       This function is invoked upon receipt of ZAP_APP_SYNC_EVT.
    821           *
    822           * input parameters
    823           *
    824           * None.
    825           *
    826           * output parameters
    827           *
    828           * None.
    829           *
    830           * @return      None.
    831           **************************************************************************************************
    832           */

   \                                 In  segment CODE, align 2
    833          static void zapSync(void)
   \                     zapSync:
    834          {
   \   000000   0A12         PUSH.W  R10
   \   000002   3182         SUB.W   #0x8, SP
    835            uint8 pBuf[Z_EXTADDR_LEN];
    836          
    837          #if ZAP_NV_RESTORE
    838            pBuf[0] = ZCD_STARTOPT_AUTO_START;
    839            (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
    840          #else
    841            (void)osal_memset(pBuf, 0, Z_EXTADDR_LEN);
   \   000004   0A41         MOV.W   SP, R10
   \   000006   0A53         ADD.W   #0x0, R10
   \   000008   3E42         MOV.W   #0x8, R14
   \   00000A   4D43         MOV.B   #0x0, R13
   \   00000C   0C4A         MOV.W   R10, R12
   \   00000E   ........     CALLA   #osal_memset
    842            if (osal_memcmp(pBuf, znpIEEE, Z_EXTADDR_LEN))
   \   000012   3E42         MOV.W   #0x8, R14
   \   000014   3D40....     MOV.W   #znpIEEE, R13
   \   000018   0C4A         MOV.W   R10, R12
   \   00001A   ........     CALLA   #osal_memcmp
   \   00001E   4C93         CMP.B   #0x0, R12
   \   000020   1224         JEQ     ??zapSync_0
    843            {
    844              zb_GetDeviceInfo(ZB_INFO_IEEE_ADDR, &znpIEEE);
   \   000022   3D40....     MOV.W   #znpIEEE, R13
   \   000026   5C43         MOV.B   #0x1, R12
   \   000028   ........     CALLA   #zb_GetDeviceInfo
    845              pBuf[0] = ZCD_STARTOPT_CLEAR_STATE | ZCD_STARTOPT_CLEAR_CONFIG;
   \   00002C   F14003000000 MOV.B   #0x3, 0(SP)
    846              (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
   \   000032   0F4A         MOV.W   R10, R15
   \   000034   5E43         MOV.B   #0x1, R14
   \   000036   4D43         MOV.B   #0x0, R13
   \   000038   3C400300     MOV.W   #0x3, R12
   \   00003C   ........     CALLA   #znp_nv_write
    847              zapPhyReset(zapAppPort);
   \   000040   ........     CALLA   #?Subroutine0
    848              return;
   \                     ??CrossCallReturnLabel_4:
   \   000044   3F3C         JMP     ??zapSync_1
    849            }
    850          #endif
    851          
    852            zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapSync_0:
   \   000046   ........     CALLA   #?Subroutine2
    853            zapAfSync();
   \                     ??CrossCallReturnLabel_6:
   \   00004A   ........     CALLA   #zapAfSync
    854            zapZdoSync();
   \   00004E   ........     CALLA   #zapZdoSync
    855          #if !ZAP_PHY_RESET_ZNP
    856            // If ZAP resets while a connected ZNP is left running, the ZNP cannot be expected to issue a
    857            // ZDO_STATE_CHANGE notification.
    858            if ((DEV_END_DEVICE == devState) || (DEV_ROUTER == devState) || (DEV_ZB_COORD == devState))
    859            {
    860              // Especially for UART transport, allow time for multiple got syncs before acting on it.
    861              if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_ZDO_STATE_CHANGE_EVT,
    862                                                            ZAP_APP_ZDO_STATE_CHANGE_DLY))
    863              {
    864                (void)osal_set_event(zapTaskId, ZAP_APP_ZDO_STATE_CHANGE_EVT);
    865              }
    866            }
    867          #endif
    868          #if ZAP_AUTO_CFG
    869            if (devState < DEV_END_DEVICE)
   \   000052   F2900600.... CMP.B   #0x6, &devState
   \   000058   262C         JC      ??zapSync_2
    870            {
    871              // Configure the defaults from zap.cfg into the ZNP.
    872              //pBuf[0] = ZAP_DEVICETYPE;
    873              //MHMS:fixing zapsync using global variable
    874              pBuf[0] = zLogicalType;
   \   00005A   D142....0000 MOV.B   &zLogicalType, 0(SP)
    875              (void)znp_nv_write(ZCD_NV_LOGICAL_TYPE, 0, 1, pBuf);
   \   000060   0F4A         MOV.W   R10, R15
   \   000062   5E43         MOV.B   #0x1, R14
   \   000064   4D43         MOV.B   #0x0, R13
   \   000066   3C408700     MOV.W   #0x87, R12
   \   00006A   ........     CALLA   #znp_nv_write
    876              //MHMS: CHANGING PANID HERE
    877              pBuf[0] = LO_UINT16(znpPanId);
   \   00006E   D142....0000 MOV.B   &znpPanId, 0(SP)
    878              pBuf[1] = HI_UINT16(znpPanId);
   \   000074   D142....0100 MOV.B   &znpPanId + 1, 0x1(SP)
    879              (void)znp_nv_write(ZCD_NV_PANID, 0, 2, pBuf);
   \   00007A   0F4A         MOV.W   R10, R15
   \   00007C   6E43         MOV.B   #0x2, R14
   \   00007E   4D43         MOV.B   #0x0, R13
   \   000080   3C408300     MOV.W   #0x83, R12
   \   000084   ........     CALLA   #znp_nv_write
    880          
    881              pBuf[0] = BREAK_UINT32(DEFAULT_CHANLIST, 0);
   \   000088   C1430000     MOV.B   #0x0, 0(SP)
    882              pBuf[1] = BREAK_UINT32(DEFAULT_CHANLIST, 1);
   \   00008C   F1420100     MOV.B   #0x8, 0x1(SP)
    883              pBuf[2] = BREAK_UINT32(DEFAULT_CHANLIST, 2);
   \   000090   C1430200     MOV.B   #0x0, 0x2(SP)
    884              pBuf[3] = BREAK_UINT32(DEFAULT_CHANLIST, 3);
   \   000094   C1430300     MOV.B   #0x0, 0x3(SP)
    885              (void)znp_nv_write(ZCD_NV_CHANLIST, 0, 4, pBuf);
   \   000098   0F4A         MOV.W   R10, R15
   \   00009A   6E42         MOV.B   #0x4, R14
   \   00009C   4D43         MOV.B   #0x0, R13
   \   00009E   3C408400     MOV.W   #0x84, R12
   \   0000A2   ........     CALLA   #znp_nv_write
    886            }
    887          #endif
    888          #if defined TC_LINKKEY_JOIN
    889            zapCertSync();
    890          #endif
    891          #if ZAP_AUTO_START
    892            if ((DEV_HOLD == devState) || (DEV_INIT == devState) || (DEV_NWK_ORPHAN == devState))
   \                     ??zapSync_2:
   \   0000A6   5E42....     MOV.B   &devState, R14
   \   0000AA   4E93         CMP.B   #0x0, R14
   \   0000AC   0524         JEQ     ??zapSync_3
   \   0000AE   5E93         CMP.B   #0x1, R14
   \   0000B0   0324         JEQ     ??zapSync_3
   \   0000B2   7E900A00     CMP.B   #0xa, R14
   \   0000B6   0420         JNE     ??zapSync_4
    893            {
    894              (void)ZDOInitDevice(NWK_START_DELAY);
   \                     ??zapSync_3:
   \   0000B8   3C406400     MOV.W   #0x64, R12
   \   0000BC   ........     CALLA   #ZDOInitDevice
    895            }
    896          #endif
    897            zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapSync_4:
   \   0000C0   ........     CALLA   #?Subroutine2
    898          }
   \                     ??zapSync_1:
   \   0000C4   3152         ADD.W   #0x8, SP
   \   0000C6   3A41         POP.W   R10
   \   0000C8   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   3D40....     MOV.W   #devState, R13
   \   000004   4C43         MOV.B   #0x0, R12
   \   000006   ........     BRA     #zb_GetDeviceInfo
    899          
    900          /**************************************************************************************************
    901           * @fn          zapSysEvtMsg
    902           *
    903           * @brief       This function is called by zapEvt() to process all of the pending OSAL messages.
    904           *
    905           * input parameters
    906           *
    907           * None.
    908           *
    909           * output parameters
    910           *
    911           * None.
    912           *
    913           * @return      None.
    914           **************************************************************************************************
    915           */
    916          static void zapSysEvtMsg(void)
    917          {
    918            uint8 *msg;
    919          
    920            while ((msg = osal_msg_receive(zapTaskId)))
    921            {
    922              switch (*msg)
    923              {
    924              case CMD_SERIAL_MSG:
    925                zapProcessIncoming(((mtOSALSerialData_t *)msg)->hdr.status, ((mtOSALSerialData_t *)msg)->msg);
    926                break;
    927          
    928          #if ZAP_APP_KEYS
    929              case KEY_CHANGE:
    930                zapKeys((keyChange_t *)msg);
    931                break;
    932          #endif
    933          
    934              default:
    935                break;
    936              }
    937          
    938              (void)osal_msg_deallocate(msg);  // Receiving task is responsible for releasing the memory.
    939            }
    940          }
    941          
    942          #if ZAP_ZNP_MT
    943          /**************************************************************************************************
    944           * @fn          MT_BuildAndSendZToolResponse
    945           *
    946           * @brief       This function is the ZAP proxy to the ZNP SystemReset() functionality.
    947           *
    948           * input parameters
    949           *
    950           * @param       cmdType - include type and subsystem
    951           * @param       cmdId - command ID
    952           * @param       dataLen
    953           * @param       *pData
    954           *
    955           * output parameters
    956           *
    957           * None.
    958           *
    959           * @return      None.
    960           **************************************************************************************************
    961           */
    962          void MT_BuildAndSendZToolResponse(uint8 cmdType, uint8 cmdId, uint8 dataLen, uint8 *pData)
    963          {
    964            uint8 *pBuf = zap_msg_allocate(dataLen, cmdType, cmdId);
    965          
    966            if (NULL != pBuf)
    967            {
    968              (void)osal_memcpy(pBuf, pData, dataLen);
    969              zapPhyUartSend(zapAppPort, pBuf);
    970              zap_msg_deallocate(&pBuf);
    971            }
    972          }
    973          #endif
    974          //MHMS: Making function to set logical type

   \                                 In  segment CODE, align 2
    975          bool zap_set_logicalType(uint8 newType)
   \                     zap_set_logicalType:
    976          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    977            
    978            switch(newType){
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   0420         JNE     ??zap_set_logicalType_0
    979              case ZG_DEVICETYPE_ROUTER:
    980                break;
    981              case ZG_DEVICETYPE_COORDINATOR:
    982                znpAddr=0;
   \   000008   8243....     MOV.W   #0x0, &znpAddr
    983                znpPanId=0xFFFF;
   \   00000C   B243....     MOV.W   #0xffff, &znpPanId
    984                break;
    985              default:
    986                break;
    987            }
    988            zapPhyReset(zapAppPort);
   \                     ??zap_set_logicalType_0:
   \   000010   ........     CALLA   #?Subroutine0
    989                if(zgWriteStartupOptions( ZG_STARTUP_SET,ZCD_STARTOPT_DEFAULT_CONFIG_STATE&&ZCD_STARTOPT_DEFAULT_NETWORK_STATE)){
   \                     ??CrossCallReturnLabel_3:
   \   000014   5D43         MOV.B   #0x1, R13
   \   000016   7C43         MOV.B   #0xff, R12
   \   000018   ........     CALLA   #zgWriteStartupOptions
   \   00001C   4C93         CMP.B   #0x0, R12
   \   00001E   0A24         JEQ     ??zap_set_logicalType_1
    990                  zapPhyReset(zapAppPort);
   \   000020   ........     CALLA   #?Subroutine0
    991                  zLogicalType=newType;
   \                     ??CrossCallReturnLabel_2:
   \   000024   C24A....     MOV.B   R10, &zLogicalType
    992                  zapSync();
   \   000028   ........     CALLA   #zapSync
    993                  zapPhyReset(zapAppPort);
   \   00002C   ........     CALLA   #?Subroutine0
    994                  return 1;
   \                     ??CrossCallReturnLabel_1:
   \   000030   5C43         MOV.B   #0x1, R12
   \   000032   013C         JMP     ??zap_set_logicalType_2
    995                }
    996                else{
    997                  return 0;
   \                     ??zap_set_logicalType_1:
   \   000034   4C43         MOV.B   #0x0, R12
   \                     ??zap_set_logicalType_2:
   \   000036   3A41         POP.W   R10
   \   000038   1001         RETA
    998                }
    999          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for zLogicalType>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "End Device">`:
   \   000000   456E64204465 DC8 "End Device"
   \            7669636500  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "ZigBee Rtr">`:
   \   000000   5A6967426565 DC8 "ZigBee Rtr"
   \            2052747200  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "ZigBee Coord">`:
   \   000000   5A6967426565 DC8 "ZigBee Coord"
   \            20436F6F7264
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Other Inval">`:
   \   000000   4F7468657220 DC8 "Other Inval"
   \            496E76616C00

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "PanId 0x">`:
   \   000000   50616E496420 DC8 "PanId 0x"
   \            307800      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Should be Coord.">`:
   \   000000   53686F756C64 DC8 "Should be Coord."
   \            20626520436F
   \            6F72642E00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Problem Writing">`:
   \   000000   50726F626C65 DC8 "Problem Writing"
   \            6D2057726974
   \            696E6700    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Should be Router">`:
   \   000000   53686F756C64 DC8 "Should be Router"
   \            20626520526F
   \            7574657200  
   1000          /**************************************************************************************************
   1001          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      30  zapDisInfo
            30 -> HalLcdWriteString
            30 -> HalLcdWriteStringValue
            30 -> osal_memcmp
            30 -> osal_memcpy
      12  zapEvt
            12 -> ZDO_UpdateNwkStatus
            12 -> osal_msg_deallocate
            12 -> osal_msg_receive
            12 -> zapKeys
            12 -> zapMonInfo
            12 -> zapMonitor
            12 -> zapPhyExec
            12 -> zapProcessIncoming
            12 -> zapSync
       4  zapGotSync
             4 -> osal_set_event
             4 -> osal_start_timerEx
             4 -> zapPhySync
       6  zapInit
             6 -> RegisterForKeys
             6 -> osal_set_event
             6 -> osal_start_timerEx
             6 -> zapLostSync
             6 -> zapPhyInit
      12  zapKeys
            12 -> HalLcdWriteStringValue
            12 -> zap_set_logicalType
       4  zapLostSync
       4  zapMonInfo
             4 -> zapDisInfo
             4 -> zb_GetDeviceInfo
       4  zapMonitor
             4 -> osal_set_event
             4 -> osal_start_timerEx
             4 -> zapMonInfo
             4 -> zapPhyReset
             4 -> zapUtilReq
             4 -> znpSystemReset
       6  zapProcessIncoming
             6 -- Indirect call
      14  zapSync
            14 -> ZDOInitDevice
            14 -> osal_memcmp
            14 -> osal_memset
            14 -> zapAfSync
            14 -> zapPhyReset
            14 -> zapZdoSync
            14 -> zb_GetDeviceInfo
            14 -> znp_nv_write
      12  zap_msg_allocate
            12 -> osal_mem_alloc
       6  zap_msg_deallocate
             6 -> halAssertHandler
             6 -> osal_mem_free
       6  zap_set_logicalType
             6 -> zapPhyReset
             6 -> zapSync
             6 -> zgWriteStartupOptions
      10  zgWriteStartupOptions
            10 -> osal_nv_read
            10 -> osal_nv_write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "End Device">
      12  ?<Constant "Other Inval">
       9  ?<Constant "PanId 0x">
      16  ?<Constant "Problem Writing">
      17  ?<Constant "Should be Coord.">
      17  ?<Constant "Should be Router">
      13  ?<Constant "ZigBee Coord">
      11  ?<Constant "ZigBee Rtr">
       1  ?<Initializer for zLogicalType>
       8  ?Subroutine0
      34  ?Subroutine1
      10  ?Subroutine2
      32  ?Subroutine3
      14  ?Subroutine4
      14  ?Subroutine5
       2  _A_PMMCTL0_L
       1  devState
       1  getInfoIdx
       1  zLogicalType
       1  zapAppPort
       2  zapDisAddr
       8  zapDisIEEE
     210  zapDisInfo
       2  zapDisPanId
       1  zapDisState
     154  zapEvt
      38  zapGotSync
      36  zapInit
      76  zapKeys
      24  zapLostSync
      98  zapMonInfo
      86  zapMonitor
      40  zapProcessFunc
      48  zapProcessIncoming
     202  zapSync
       1  zapTaskId
      84  zap_msg_allocate
      32  zap_msg_deallocate
      58  zap_set_logicalType
       2  zgTrustCenterAddr
      54  zgWriteStartupOptions
       2  znpAddr
       8  znpIEEE
       2  znpPanId
       2  znpParent

 
 1 312 bytes in segment CODE
     2 bytes in segment DATA16_AN
   146 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    33 bytes in segment DATA16_Z
 
 1 312 bytes of CODE  memory
   147 bytes of CONST memory
    34 bytes of DATA  memory (+ 2 bytes shared)

Errors: none
Warnings: none
